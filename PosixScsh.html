<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>
SRFI FIXME: Scsh P<small>OSIX</small>API 
</title>
<link rel="stylesheet" type="text/css" href="./This SRFI Reference Manual_files/man-Z-S.css" title="default">
<meta name="robots" content="noindex,follow">
</head>
<body>
<div id="content">
<p></p>
<p>
<p>
WG2 voted to provide a Posix package, but rejected a "full Posix" package that would provide all 81
headers, 1191 interfaces, and 51 data types from POSIX.1-2008.  What is proposed here is based
directly on the Posix bindings for Lua, which are modern and thorough
without being insanely comprehensive.  They have been reduced to those
available directly or indirectly in `scsh`.
</p>
This SRFI provides (almost) complete access to the basic Unix kernel services:
processes, files, signals and so forth.  These procedures comprise a 
Scheme binding for P<small>OSIX</small>.
</p>
<p>
</p>
<a name="node_sec_3.1"></a>
<h2><a href="#node_toc_node_sec_3.1">3.1&nbsp;&nbsp;Errors</a></h2>
<p>This SRFI syscalls never return error codes, and do not use a global
<tt>errno</tt> variable to report errors.
Errors are consistently reported by raising exceptions.
This frees up the procedures to return useful values,
and allows the programmer to assume that 
<em>if a syscall returns, it succeeded.</em>
This greatly simplifies the flow of the code from the programmer's point
of view.</p>
<p>
Since Scheme does not yet have a standard exception system, the SRFI
definition remains somewhat vague on the actual form of exceptions
and exception handlers. When a standard exception system is defined,
SRFI will move to it. For now, scsh uses the Scheme 48 exception system,
with a simple sugaring on top to hide the details in the common case.</p>
<p>
System call error exceptions contain the Unix <tt>errno</tt> code reported by
the system call. Unlike C, the <tt>errno</tt> value is a part of the exception
packet, it is <em>not</em> accessed through a global variable.</p>
<p>
For reference purposes, the Unix <tt>errno</tt> numbers 
are bound to the variables <tt>errno/perm</tt>, <tt>errno/noent</tt>, <em>etc.</em>
System calls never return <tt>error/intr</tt> -- they
automatically retry.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_68"></a><div align="left"><tt>(errno-error <i>errno syscall . data</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Raises a Unix error exception for Unix error number <i>errno</i>.
The <i>syscall</i> and <i>data</i> arguments are packaged up in the exception
packet passed to the exception handler.
</blockquote><p>
<a name="node_idx_70"></a></p>
<div align="left"><tt>(with-errno-handler* <i>handler thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_72"></a><div align="left"><tt>(with-errno-handler <i>handler-spec . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>value&nbsp;of&nbsp;body</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>
<blockquote>
Unix syscalls raise error exceptions by calling <tt>errno-error</tt>.
Programs can use <tt>with-errno-handler*</tt> to establish
handlers for these exceptions.<p>
If a Unix error arises while <i>thunk</i> is executing, 
<i>handler</i> is called on two arguments like this:
</p>
<blockquote><tt>(<i>handler</i> <i>errno</i> <i>packet</i>)</tt></blockquote><i>packet</i> is a list of the form
<div align="center"><table><tbody><tr><td><i>packet</i>  =  <tt>(<i>errno-msg</i> <i>syscall</i> . <i>data</i>)</tt>,</td></tr></tbody></table></div><p>
where <i>errno-msg</i> is the standard Unix error message for the error,
<i>syscall</i> is the procedure that generated the error,
and   <i>data</i> is a list of information generated by the error,
which varies from syscall to syscall.</p>
<p>
If <i>handler</i> returns, the handler search continues upwards.
<i>Handler</i> can acquire the exception by invoking a saved continuation.
This procedure can be sugared over with the following syntax:
</p>
<blockquote><tt><br>
(with-errno-handler<br>
&nbsp;&nbsp;&nbsp;&nbsp;((<i>errno</i>&nbsp;<i>packet</i>)&nbsp;<i>clause</i>&nbsp;<tt>...</tt>)<br>
&nbsp;&nbsp;<i>body1</i><br>
&nbsp;&nbsp;<i>body2</i><br>
&nbsp;&nbsp;<tt>...</tt>)</tt></blockquote>
This form executes the body forms with a particular errno handler installed.
When an errno error is raised, the handler search machinery will
bind variable <i>errno</i> to the error's integer code, and variable
<i>packet</i> to the error's auxiliary data packet.
Then, the clauses will be checked for a match.
The first clause that matches is executed, and its value is the
value of the entire <tt>with-errno-handler</tt> form.
If no clause matches, the handler search continues.<p>
Error clauses have two forms
</p>
<blockquote><tt><br>
((<i>errno</i>&nbsp;<tt>...</tt>)&nbsp;<i>body</i>&nbsp;<tt>...</tt>)<br>
(else&nbsp;<i>body</i>&nbsp;<tt>...</tt>)</tt></blockquote>
In the first type of clause, the <i>errno</i> forms are integer expressions.
They are evaluated and compared to the error's errno value.
An <tt>else</tt> clause matches any errno value. 
Note that the <i>errno</i> and <i>data</i>
variables are lexically visible to the error clauses.<p>
Example:
</p>
<blockquote><tt>&nbsp;&nbsp;&nbsp;&nbsp;<br>
(with-errno-handler&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;((errno&nbsp;packet)&nbsp;;&nbsp;Only&nbsp;handle&nbsp;3&nbsp;particular&nbsp;errors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/wouldblock&nbsp;errno/again)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/acces)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;#t&nbsp;"Not&nbsp;allowed&nbsp;access!")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f))<br>
<br>
&nbsp;&nbsp;(foo&nbsp;frobbotz)<br>
&nbsp;&nbsp;(blatz&nbsp;garglemumph))</tt></blockquote>
It is not defined what dynamic context the handler executes in.
<p>
Note that This SRFI system calls always retry when interrupted, so that
the <tt>errno/intr</tt> exception is never raised.
If the programmer wishes to abort a system call on an interrupt, he
should have the interrupt handler explicitly raise an exception or
invoke a stored continuation to throw out of the system call.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.2"></a>
<h2><a href="#node_toc_node_sec_3.2">3.2&nbsp;&nbsp;I/O</a></h2>
<p></p>
<a name="node_sec_3.2.1"></a>
<h3><a href="#node_toc_node_sec_3.2.1">3.2.1&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.2"></a>
<h3><a href="#node_toc_node_sec_3.2.2">3.2.2&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.3"></a>
<h3><a href="#node_toc_node_sec_3.2.3">3.2.3&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.4"></a>
<h3><a href="#node_toc_node_sec_3.2.4">3.2.4&nbsp;&nbsp;Ports and file descriptors</a></h3>
<p>
Dealing with Unix file descriptors in a Scheme environment is difficult. 
In Unix, open files are part of the process environment, and are referenced
by small integers called <em>file descriptors</em>. Open file descriptors are
the fundamental way I/O redirections are passed to subprocesses, since
file descriptors are preserved across fork's and exec's.</p>
<p>
Scheme, on the other hand, uses ports for specifying I/O sources. Ports are
garbage-collected Scheme objects, not integers. Ports can be garbage
collected; when a port is collected, it is also closed. Because file
descriptors are just integers, it's impossible to garbage collect them -- you
wouldn't be able to close file descriptor 3 unless there were no 3's in the
system, and you could further prove that your program would never again
compute a 3. This is difficult at best.</p>
<p>
If a Scheme program only used Scheme ports, and never actually used
file descriptors, this would not be a problem. But Scheme code
must descend to the file descriptor level in at least two circumstances:
</p>
<ul>    
<li><p>when interfacing to foreign code
</p>
</li><li><p>when interfacing to a subprocess.
</p>
</li></ul><p>
This causes a problem. Suppose we have a Scheme port constructed
on top of file descriptor 2. We intend to fork off a program that
will inherit this file descriptor. If we drop references to the port,
the garbage collector may prematurely close file 2 before we fork
the subprocess. The interface described below is intended to fix this and 
other problems arising from the mismatch between ports and file descriptors.</p>
<p>
Unfortunately, there is no even vaguely portable solution to this problem.
Scsh undertakes heroic measures to prevent ports from being garbage
collected when their file descriptors are separately in use, but this
is more change than an implementation should have to accept in order
to provides this SRFI.</p>

<p>Consequently, care must be taken when accessing a Scheme port through
its file descriptor.  If the program does not maintain a reference to the
port, the file descriptor may be closed when the port is garbage collected.
In the same way, if a file descriptor is duplicated with <code>dup2()</code>
and that file descriptor happens to be in use by an open port, further
operations on that port have undefined results.</p>
<p>The following routines allow conversion between ports and file
descriptors.</p>
<p><a name="node_idx_114"></a></p>
<div align="left"><tt>(fdes-&gt;textual-input-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div align="left"><tt>(fdes-&gt;binary-input-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_116"></a><div align="left"><tt>(fdes-&gt;textual-output-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_116"></a><div align="left"><tt>(fdes-&gt;binary-output-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>These wrap a newly created port around the specified file descriptor.</p>
<p><i>Compatibility note: Scsh provides only <code>fdes->inport</code> and
<code>fdes->outport</code>, as it does not distinguish between
textual and binary ports.</i></p>
</blockquote>

<a name="node_idx_118"></a><div align="left"><tt>(port-&gt;fdes <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This exposes the file descriptor of a port.
</blockquote><p>
</p>
<a name="node_sec_3.2.5"></a>
<h3><a href="#node_toc_node_sec_3.2.5">3.2.5&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.6"></a>
<h3><a href="#node_toc_node_sec_3.2.6">3.2.6&nbsp;&nbsp;Unix I/O</a></h3>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_128"></a></p>
<a name="node_idx_134"></a><div align="left"><tt>(dup-&gt;fdes <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>fd</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure provides the functionality of the P<small>OSIX</small>
<code>dup()</code> and <code>dup2()</code> functions.
These procedures use the Unix <tt>dup()</tt> syscall to replicate
the file descriptor or file port <i>fd/port</i>.
If a <i>newfd</i> file descriptor is given, it is used as the target of
the dup operation, <em>i.e.</em>, the operation is a <tt>dup2()</tt>.
<p>
If the <i>newfd</i> target is given, 
and some port is already using that file descriptor,
the result of using that port is undefined.</p>
</blockquote>
<p></p>
<p></p>
<p><a name="node_idx_136"></a></p>
<div align="left"><tt>(seek <i>fd/port offset [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Reposition the I/O cursor for a file descriptor or port.
<i>whence</i> is one of {<tt>seek/set</tt>, <tt>seek/delta</tt>, <tt>seek/end</tt>},
and defaults to <tt>seek/set</tt>.
If <tt>seek/set</tt>, then <i>offset</i> is an absolute index into the file;
if <tt>seek/delta</tt>, then <i>offset</i> is a relative offset from the current
I/O cursor;
if <tt>seek/end</tt>, then <i>offset</i> is a relative offset from the end of file.
The <i>fd/port</i> argument may be a port or an integer file descriptor.
Not all such values are seekable;
this is dependent on the OS implementation.
The return value is the resulting position of the I/O cursor in the I/O stream.
<blockquote><i>Oops: </i> The current implementation doesn't handle <i>offset</i> arguments
that are not immediate integers (<em>i.e.</em>, representable in 30 bits).</blockquote>
<blockquote><i>Oops: </i> The current implementation doesn't handle buffered ports.</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_138"></a></p>
<div align="left"><tt>(tell <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the position of the I/O cursor in the the I/O stream.
Not all file descriptors or ports support cursor-reporting; 
this is dependent on the OS implementation.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_140"></a><div align="left"><tt>(open-file <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<i>Perms</i> defaults to <tt>#o666</tt>.
<i>Flags</i> is an integer bitmask, composed by or'ing together constants
listed in table&nbsp;<a href="#node_tbl_Temp_2">1</a> 
(page&nbsp;<a href="">4</a>).
You must use exactly one of the <tt>open/read</tt>, <tt>open/write</tt>, or
<tt>open/read+write</tt> flags.
The returned port is an input port if the <i>flags</i> permit it, 
otherwise an output port. R5RS/Scheme 48/SRFI do not have input/output ports,
so it's one or the other. This should be fixed. (You can hack simultaneous
I/O on a file by opening it r/w, taking the result input port, 
and duping it to an output port with <tt>dup-&gt;outport</tt>.)
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_142"></a></p>
<p></p>
<p></p>
<a name="node_idx_146"></a><div align="left"><tt>(open-fdes <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns a file descriptor.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_152"></a></p>
<div align="left"><tt>(fdes-status <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_154"></a><div align="left"><tt>(set-fdes-status <i>fd/port <i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures allow reading and writing of an open file's status flags
(table&nbsp;<a href="#node_tbl_Temp_2">1</a>).
<p></p>
<hr>
<p></p>
<a name="node_tbl_Temp_2"></a>
<div class="table" align="center"><table width="100%"><tbody><tr><td align="center"><div align="center"><table><tbody><tr><td>

<table border="0"><tbody><tr><td valign="top"></td><td valign="top">Allowed operations </td><td valign="top">Status flag </td></tr>
<tr><td valign="top">
<b>Open+Get+Set</b> </td><td valign="top">These flags can be used in <tt>open-file</tt>, <tt>fdes-status</tt>,
and <tt>set-fdes-status</tt> calls. </td><td valign="top"><table border="0"><tbody><tr><td valign="top">open/append         </td></tr>
<tr><td valign="top">open/non-blocking   </td></tr>
<tr><td valign="top">open/async (Non-P<small>OSIX</small>) </td></tr>
<tr><td valign="top">open/fsync (Non-P<small>OSIX</small>)
</td></tr></tbody></table>
</td></tr>
<tr><td valign="top">
<b>Open+Get</b> </td><td valign="top">These flags can be used in <tt>open-file</tt> and <tt>fdes-status</tt> calls,
but are ignored by <tt>set-fdes-status</tt>. </td><td valign="top"><table border="0"><tbody><tr><td valign="top">open/read           </td></tr>
<tr><td valign="top">open/write          </td></tr>
<tr><td valign="top">open/read+write     </td></tr>
<tr><td valign="top">open/access-mask
</td></tr></tbody></table>
</td></tr>
<tr><td valign="top">
<b>Open</b> </td><td valign="top">These flags are only relevant in 
<tt>open-file</tt> calls; 
they are ignored by <tt>fdes-status</tt> and <tt>set-fdes-status</tt> calls. </td><td valign="top"><table border="0"><tbody><tr><td valign="top">open/create         </td></tr>
<tr><td valign="top">open/exclusive              </td></tr>
<tr><td valign="top">open/no-control-tty </td></tr>
<tr><td valign="top">open/truncate               
</td></tr></tbody></table>
</td></tr></tbody></table>
</td></tr></tbody></table></div>

</td></tr>
<tr><td align="center"><b>Table 1:</b>&nbsp;&nbsp;Status flags for <tt>open-file</tt>,
<tt>fdes-status</tt> and <tt>set-fdes-status</tt>.
Only P<small>OSIX</small> flags are guaranteed to be present;
your operating system may define others.
The <tt>open/access-mask</tt> value is not an actual flag,
but a bit mask used to select the field for the <tt>open/read</tt>,
<tt>open/write</tt> and <tt>open/read+write</tt> bits.
</td></tr>
<tr><td>

</td></tr></tbody></table></div><p></p>
<hr>
<p></p>
<p></p>
<p>
Note that this file-descriptor state is shared between file descriptors
created by <tt>dup</tt> -- if you create port <i>b</i> by applying <tt>dup</tt>
to port <i>a</i>, and change <i>b</i>'s status flags, you will also have
changed <i>a</i>'s status flags.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_156"></a><div align="left"><tt>(pipe<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>rport</i> <i>wport</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns two ports, the read and write end-points of a Unix pipe.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_170"></a></p>
<div align="left"><tt>(select-ports <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>select-ports</tt> call will block until at least one of the
ports passed to it is ready for operation or until the timeout has
expired.  For an input port this means that it either has data
sitting its buffer or that the underlying file descriptor has data
waiting.  For an output port this means that it either has space
available in the associated buffer or that the underlying file
descriptor can accept output.<p>
The <i>timeout</i> value can be used to force the call to time out
after a given number of seconds.  A value of <tt>#f</tt> means to wait
indefinitely.  A zero value can be used to poll the ports.</p>
<p>
<tt>Select-ports</tt> returns a list of the ports ready for
operation.  Note that this list may be empty if the timeout expired
before any ports became ready.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_172"></a></p>
<div align="left"><tt>(select-port-channels <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<tt>Select-port-channels</tt> is like <tt>select-ports</tt>, except
that it only looks at the operating system objects the ports refer
to, ignoring any buffering performed by the ports.<p>
</p>
<blockquote><i>Remark: </i> <tt>Select-port-channels</tt> should be used with care: for
example, if an input port has data in the buffer but no data
available on the underlying file descriptor,
<tt>select-port-channels</tt> will block, even though a read
operation on the port would be able to complete without blocking.<p>
<tt>Select-port-channels</tt> is intended for situations where the
program is not checking for available data, but rather for waiting
until a port has established a connection -- for example, to a
network port.</p>
</blockquote>
</blockquote><p>
</p>
<a name="node_sec_3.2.7"></a>
<h3><a href="#node_toc_node_sec_3.2.7">3.2.7&nbsp;&nbsp;Buffered I/O</a></h3>
<p>Scheme 48 ports use buffered I/O -- data is transferred to or from the
OS in blocks. This SRFI provides control of this mechanism: the programmer
may force saved-up output data to be transferred to the OS when
he chooses, 
and may also choose which I/O buffering policy to employ for a given
port (or turn buffering off completely). </p>
<p>
It can be useful to turn I/O buffering off in some cases, for example
when an I/O stream is to be shared by multiple subprocesses.
For this reason, SRFI allocates an unbuffered port for file descriptor 0
at start-up time.
Because shells frequently share stdin with subprocesses, if the shell
does buffered reads, it might "steal" input intended for a subprocess.  For
this reason, all shells, including sh, csh, and SRFI, read stdin unbuffered.
Applications that can tolerate buffered input on stdin can reset
<tt>(current-input-port)</tt> to block buffering for higher performance.</p>
<p>
{Note: To support <tt>peek-char</tt> a Scheme implementation has to
maintain a buffer for all input ports. In this SRFI, for "unbuffered"
input ports the buffer size is one. As you cannot request less then
one character there is no unrequested reading so this can still be
called "unbuffered input".}</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_178"></a><div align="left"><tt>(set-port-buffering <i>port policy [size]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure allows the programmer to assign a particular I/O buffering
policy to a port, and to choose the size of the associated buffer.
It may only be used on new ports, <em>i.e.</em>, before I/O is performed on the port.
There are three buffering policies that may be chosen:
<blockquote>
<table border="0"><tbody><tr><td valign="top"><a name="node_idx_180"></a><tt>bufpol/block</tt> </td><td valign="top">General block buffering (general default) </td></tr>
<tr><td valign="top"><a name="node_idx_182"></a><tt>bufpol/line</tt>  </td><td valign="top">Line buffering (tty default) </td></tr>
<tr><td valign="top"><a name="node_idx_184"></a><tt>bufpol/none</tt>  </td><td valign="top">Direct I/O -- no buffering<a name="node_call_footnote_4"></a><a href="#node_footnote_4"><sup><small>4</small></sup></a>
</td></tr></tbody></table>
</blockquote>
The line buffering policy flushes output whenever a newline is output;
whenever the buffer is full; or whenever an input is read from stdin.
Line buffering is the default for ports open on terminal devices.
<blockquote><i>Oops: </i> The current implementation doesn't support <tt>bufpol/line</tt>.</blockquote><p>
The <i>size</i> argument requests an I/O buffer of <i>size</i> bytes.
For output ports, <i>size</i> must be non-negative, for input ports
<i>size</i> must be positve. If not given, a reasonable default is
used. For output ports, if given and zero, buffering is turned off
(<em>i.e.</em>, <i>size</i>  =  0 for any policy is equivalent to <i>policy</i>  = 
<tt>bufpol/none</tt>). For input ports, setting the size to one
corresponds to unbuffered input as defined above. If given, <i>size</i>
must be zero respectively one for <tt>bufpol/none</tt>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_sec_3.2.8"></a>
<h3><a href="#node_toc_node_sec_3.2.8">3.2.8&nbsp;&nbsp;File locking</a></h3>
<p>
This SRFI provides P<small>OSIX</small> advisory file locking.
<em>Advisory</em> locks are locks that can be checked by user code, 
but do not affect other I/O operations.
For example, if a process has an exclusive lock on a region of a file,
other processes will not be able to obtain locks on that region of the file,
but they will still be able to read and write the file with no hindrance.
Using advisory locks requires cooperation amongst the agents accessing
the shared resource.</p>
<p>
</p>
<blockquote><i>Remark: </i> 
Unfortunately, P<small>OSIX</small> file locks are associated with actual files,
not with associated open file descriptors.
Once a process locks a file, using some file descriptor <i>fd</i>,
the next time <em>any</em> file descriptor referencing that file is closed, 
all associated locks are released.
This severely limits the utility of P<small>OSIX</small> advisory file locks,
and we'd recommend caution when using them.
It is not without reason that the FreeBSD man pages refer to P<small>OSIX</small>
file locking as "completely stupid."<p>
This means the file-locking procedures can then be applied to the port's
associated file descriptor.
</p>
</blockquote><p>
P<small>OSIX</small> allows the user to lock a region of a file with either 
an exclusive or shared lock.
Locked regions are described by the <em>lock-region</em> record:
</p>
<blockquote><tt><br>
(define-record&nbsp;lock-region<br>
&nbsp;&nbsp;exclusive?<br>
&nbsp;&nbsp;start<br>
&nbsp;&nbsp;len<br>
&nbsp;&nbsp;whence<br>
&nbsp;&nbsp;proc)</tt></blockquote><a name="node_idx_190"></a><a name="node_idx_192"></a> <a name="node_idx_194"></a><a name="node_idx_196"></a> <a name="node_idx_198"></a><a name="node_idx_200"></a> <a name="node_idx_202"></a><ul>
<li><p>The <tt>exclusive?</tt> field is true if the lock is exclusive; 
false if it is shared.</p>
<p>
</p>
</li><li><p>The <tt>whence</tt> field is one of the values from the <tt>seek</tt> call:
<tt>seek/set</tt>, <tt>seek/delta</tt>, or <tt>seek/end</tt>, 
and determines the interpretation of the <tt>start</tt> field:
</p>
<ul>
<li><p>If <tt>seek/set</tt>, the <tt>start</tt> value is simply an absolute index
into the file.
</p>
</li><li><p>If <tt>seek/delta</tt>, the <tt>start</tt> value is an offset from the 
file descriptor's current position in the file.
</p>
</li><li><p>If <tt>seek/end</tt>, the <tt>start</tt> value is an offset from the 
end of the file.
</p>
</li></ul><p>
The region of the file being locked is given by the <tt>start</tt> and <tt>len</tt>
fields;
if <tt>len</tt> is zero, it means "infinity," that is, the region extends
from the starting point through the end of the file, even as the file is
extended by subsequent write operations.</p>
<p>
</p>
</li><li><p>The <tt>proc</tt> field gives the process object for the process holding the region
lock, when relevant (see <tt>get-lock-region</tt> below).
</p>
</li></ul><p></p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_204"></a><div align="left"><tt>(make-lock-region <i>exclusive? start len [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure makes a lock-region record. 
The <tt>whence</tt> field defaults to <tt>seek/set</tt>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_206"></a></p>
<div align="left"><tt>(lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_208"></a><div align="left"><tt>(lock-region/no-block <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures lock a region of the file referenced by file descriptor
<i>fdes</i>.
The <tt>lock-region</tt> procedure blocks until the lock is granted;
the non-blocking variant returns a boolean indicating whether or not
the lock was granted.
To take an exclusive (write) lock, you must have the file descriptor
open with write access;
to take a shared (read) lock, you must have the file descriptor
open with read access.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_210"></a><div align="left"><tt>(get-lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the first lock region on <i>fdes</i> that would conflict with 
lock region <i>lock</i>.
If there is no such lock region, return false.
This procedure fills out the <tt>proc</tt> field of the returned lock region,
and is the only procedure that has anything to do with this field.
(See section&nbsp;<a href="#node_sec_3.4.1">3.4.1</a> for a description of process objects.)
Note that if you apply this procedure to a file system that is shared
across multiple operating systems (<em>i.e.</em>, an NFS file system), the <tt>proc</tt>
field may be ambiguous.
We note, again, that P<small>OSIX</small> advisory file locking is not a terribly useful
or well-designed facility.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_212"></a><div align="left"><tt>(unlock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Release a lock from a file.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_214"></a></p>
<div align="left"><tt>(with-region-lock* <i>fdes lock thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_216"></a><div align="left"><tt>(with-region-lock <i>fdes lock body <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
This procedure obtains the requested lock, and then calls 
<tt>(<i>thunk</i>)</tt>. When <i>thunk</i> returns, the lock is released.
A non-local exit (<em>e.g.</em>, throwing to a saved continuation or raising
an exception) also causes the lock to be released.<p>
After a normal return from <i>thunk</i>, its return values are returned
by <tt>with-region-lock*</tt>.
The <tt>with-region-lock</tt> special form is equivalent syntactic sugar.
</p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.3"></a>
<h2><a href="#node_toc_node_sec_3.3">3.3&nbsp;&nbsp;File system</a></h2>
<p>The following procedures allow access to the
computer's file system.
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_218"></a></p>
<div align="left"><tt>(create-directory <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_220"></a><div align="left"><tt>(create-fifo <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_222"></a><div align="left"><tt>(create-hard-link <i>oldname newname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_224"></a><div align="left"><tt>(create-symlink <i>old-name new-name [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
These procedures create objects of various kinds in the file system.</p>
<p>
The <i>override?</i> argument controls the action if there is already an
object in the file system with the new name:
</p>
<blockquote><table border="0"><tbody><tr><td valign="top"><tt>#f</tt></td><td valign="top">signal an error (default) </td></tr>
<tr><td valign="top"><tt>#t</tt></td><td valign="top">
delete the old object (with <tt>delete-file</tt>
or <tt>delete-directory,</tt> as appropriate) before
creating the new object.<p>
</p>
</td></tr></tbody></table></blockquote><p>
<i>Perms</i> defaults to <tt>#o777</tt> (but is masked by the current umask).</p>
<p>
</p>
<blockquote><i>Remark: </i> Currently, if you try to create a hard or symbolic link from a
file to itself, you will error out with <i>override?</i> false, and simply
delete your file with <i>override?</i> true. Catching this will require
some sort of true-name procedure, which I currently do not have.</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_226"></a></p>
<div align="left"><tt>(delete-directory <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure deletes directories from the file system.
</p>
</blockquote><p>
</p>
<a name="node_idx_232"></a><div align="left"><tt>(read-symlink <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Return the filename referenced by symbolic link <tt>fname</tt>.
</blockquote><p>
</p>
<a name="node_idx_234"></a><div align="left"><tt>(rename-file <i>old-fname new-fname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>If you override an existing object, then <i>old-fname</i> 
and <i>new-fname</i> must type-match -- either both directories, 
or both non-directories. 
This is required by the semantics of Unix <tt>rename()</tt>.<p>
</p>
<blockquote><i>Remark: </i> 
There is an unfortunate atomicity problem with the <tt>rename-file</tt> 
procedure: if you
specify no-override, but create file <tt>new-fname</tt> sometime between
<tt>rename-file</tt>'s existence check and the actual rename operation,
your file will be clobbered with <tt>old-fname</tt>. There is no way to fix
this problem, given the semantics of Unix <tt>rename()</tt>; 
at least it is highly unlikely to occur in practice.
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_236"></a></p>
<div align="left"><tt>(set-file-mode <i>fname/fd/port mode</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_238"></a><div align="left"><tt>(set-file-owner <i>fname/fd/port uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_240"></a><div align="left"><tt>(set-file-group <i>fname/fd/port gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>    
These procedures set the permission bits, owner id, and group id of a
file, respectively.
The file can be specified by giving the file name, or either an
integer file descriptor or a port open on the file.
Setting file user ownership usually requires root privileges.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_242"></a></p>
<div align="left"><tt>(set-file-times <i>fname [access-time mod-time]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure sets the access and modified times for the file
<i>fname</i> to the supplied values (see section&nbsp;<a href="#node_sec_3.10">3.10</a>
for the SRFI representation of time).
If neither time argument is supplied, they are both taken to be
the current time. You must provides both times or neither.
If the procedure completes successfully, the file's time of last
status-change (<tt>ctime</tt>) is set to the current time.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_244"></a></p>
<div align="left"><tt>(sync-file <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_246"></a><div align="left"><tt>(sync-file-system<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Calling <tt>sync-file</tt>
causes Unix to update the disk data structures for a given file.
If <i>fd/port</i> is a port, any buffered data it may have is first
flushed. 
Calling <tt>sync-file-system</tt> synchronises the kernel's entire file
system with the disk.<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_248"></a><div align="left"><tt>(truncate-file <i>fname/fd/port len</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>The specified file is truncated to <i>len</i> bytes in length.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_250"></a><div align="left"><tt>(file-info <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>file-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The <tt>file-info</tt> procedure
returns a record structure containing everything
there is to know about a file. If the <i>chase?</i> flag is true
(the default), then the procedure chases symlinks and reports on
the files to which they refer. If <i>chase?</i> is false, then 
the procedure checks the actual file itself, even if it's a symlink.
The <i>chase?</i> flag is ignored if the file argument is a file descriptor
or port.<p>
The value returned is a <em>file-info record</em>, defined to have the
following structure:
</p>
<blockquote><tt><br>
(define-record&nbsp;file-info<br>
&nbsp;&nbsp;type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;{block-special,&nbsp;char-special,&nbsp;directory,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fifo,&nbsp;regular,&nbsp;socket,&nbsp;symlink}<br>
&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Device&nbsp;file&nbsp;resides&nbsp;on.<br>
&nbsp;&nbsp;inode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;inode.<br>
&nbsp;&nbsp;mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;mode&nbsp;bits:&nbsp;permissions,&nbsp;setuid,&nbsp;setgid<br>
&nbsp;&nbsp;nlinks&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Number&nbsp;of&nbsp;hard&nbsp;links&nbsp;to&nbsp;this&nbsp;file.<br>
&nbsp;&nbsp;uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Owner&nbsp;of&nbsp;file.<br>
&nbsp;&nbsp;gid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;File's&nbsp;group&nbsp;id.<br>
&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Size&nbsp;of&nbsp;file,&nbsp;in&nbsp;bytes.<br>
&nbsp;&nbsp;atime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;access.<br>
&nbsp;&nbsp;mtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;mod.<br>
&nbsp;&nbsp;ctime)&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Time&nbsp;of&nbsp;last&nbsp;status&nbsp;change.</tt></blockquote>
<a name="node_idx_252"></a><a name="node_idx_254"></a><a name="node_idx_256"></a><a name="node_idx_258"></a><a name="node_idx_260"></a><a name="node_idx_262"></a><a name="node_idx_264"></a><a name="node_idx_266"></a><a name="node_idx_268"></a><a name="node_idx_270"></a><a name="node_idx_272"></a>
The <tt>type</tt> field is a symbol; all other fields are integers.
A file-info record is discriminated with the <tt>file-info?</tt> predicate.<p>
The following procedures all return selected information about
a file; they are built on top of <tt>file-info</tt>, and are
called with the same arguments that are passed to it.
</p>
<blockquote>
<table border="0"><tbody><tr><td valign="top">Procedure </td><td valign="top">returns </td></tr>
<tr><td valign="top"><a name="node_idx_274"></a><tt>file-type</tt>          </td><td valign="top">type </td></tr>
<tr><td valign="top"><a name="node_idx_276"></a><tt>file-inode</tt>         </td><td valign="top">inode </td></tr>
<tr><td valign="top"><a name="node_idx_278"></a><tt>file-mode</tt>          </td><td valign="top">mode </td></tr>
<tr><td valign="top"><a name="node_idx_280"></a><tt>file-nlinks</tt>        </td><td valign="top">nlinks </td></tr>
<tr><td valign="top"><a name="node_idx_282"></a><tt>file-owner</tt>         </td><td valign="top">uid </td></tr>
<tr><td valign="top"><a name="node_idx_284"></a><tt>file-group</tt>         </td><td valign="top">gid </td></tr>
<tr><td valign="top"><a name="node_idx_286"></a><tt>file-size</tt>          </td><td valign="top">size </td></tr>
<tr><td valign="top"><a name="node_idx_288"></a><tt>file-last-access</tt>   </td><td valign="top">atime </td></tr>
<tr><td valign="top"><a name="node_idx_290"></a><tt>file-last-mod</tt>      </td><td valign="top">mtime </td></tr>
<tr><td valign="top"><a name="node_idx_292"></a><tt>file-last-status-change</tt> </td><td valign="top">ctime
</td></tr></tbody></table>
</blockquote>
Example:
<blockquote><tt>&nbsp;&nbsp;&nbsp;&nbsp;<br>
;;&nbsp;All&nbsp;my&nbsp;files&nbsp;in&nbsp;/usr/tmp:<br>
(filter&nbsp;(lambda&nbsp;(f)&nbsp;(=&nbsp;(file-owner&nbsp;f)&nbsp;(user-uid)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(directory-files&nbsp;"/usr/tmp")))</tt></blockquote><p>
</p>
</blockquote><p>
<p></p>
<p></p>
<p><a name="node_idx_294"></a></p>
<div align="left"><tt>(file-directory? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_296"></a><div align="left"><tt>(file-fifo? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_298"></a><div align="left"><tt>(file-regular? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_300"></a><div align="left"><tt>(file-socket? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_302"></a><div align="left"><tt>(file-special? <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_304"></a><div align="left"><tt>(file-symlink? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures are file-type predicates that test the
type of a given file.
They are applied to the same arguments to which <tt>file-info</tt> is applied;
the sole exception is <tt>file-symlink?</tt>, which does not take
the optional <i>chase?</i> second argument.
<blockquote>
<table border="0"><tbody><tr><td valign="top"></td></tr></tbody></table>
</blockquote>
For example,
<blockquote><tt>(file-directory? "/usr/dalbertz")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;===&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>#t</tt></tt></blockquote></blockquote><p>
There are variants of these procedures which work directly on
<tt>file-info</tt> records:
</p>
<p></p>
<p></p>
<p><a name="node_idx_306"></a></p>
<div align="left"><tt>(file-info-directory? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_308"></a><div align="left"><tt>(file-info-fifo? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_310"></a><div align="left"><tt>(file-info-regular? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_312"></a><div align="left"><tt>(file-info-socket? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_314"></a><div align="left"><tt>(file-info-special? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_316"></a><div align="left"><tt>(file-info-symlink? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
The following set of procedures are a convenient means to work on the
permission bits of a file:</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_318"></a></p>
<div align="left"><tt>(file-not-readable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_320"></a><div align="left"><tt>(file-not-writable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_322"></a><div align="left"><tt>(file-not-executable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns:
<blockquote><table border="0"><tbody><tr><td valign="top">Value      </td><td valign="top">meaning </td></tr>
<tr><td valign="top"><tt>#f</tt></td><td valign="top">Access permitted </td></tr>
<tr><td valign="top">'search-denied          </td><td valign="top"><table border="0"><tbody><tr><td valign="top">Can't stat -- a protected directory </td></tr>
<tr><td valign="top">is blocking access.</td></tr></tbody></table> </td></tr>
<tr><td valign="top">'permission             </td><td valign="top">Permission denied. </td></tr>
<tr><td valign="top">'no-directory           </td><td valign="top">Some directory doesn't exist. </td></tr>
<tr><td valign="top">'nonexistent            </td><td valign="top">File doesn't exist.
</td></tr></tbody></table></blockquote>
A file is considered writeable if either (1) it exists and is writeable
or (2) it doesn't exist and the directory is writeable.
Since symlink permission bits are ignored by the filesystem, these
calls do not take a <i>chase?</i> flag.<p>
Note that these procedures use the process' <em>effective</em> user
and group ids for permission checking. P<small>OSIX</small> defines an <tt>access()</tt>
function that uses the process' real uid and gids. This is handy
for setuid programs that would like to find out if the actual user
has specific rights; SRFI ought to provides this functionality (but doesn't
at the current time). </p>
<p>
There are several problems with these procedures. First, there's an
atomicity issue. In between checking permissions for a file and then trying
an operation on the file, another process could change the permissions,
so a return value from these functions guarantees nothing. Second, 
the code special-cases permission checking when the uid is root -- if
the file exists, root is assumed to have the requested permission.
However, not even root can write a file that is on a read-only file system,
such as a CD ROM. In this case, <tt>file-not-writable?</tt> will lie, saying
that root has write access, when in fact the opening the file for write
access will fail.
Finally, write permission confounds write access and create access.
These should be disentangled.</p>
<p>
Some of these problems could be avoided if P<small>OSIX</small> had a real-uid
variant of the <tt>access()</tt> call we could use, but the atomicity
issue is still a problem. In the final analysis, the only way to
find out if you have the right to perform an operation on a file
is to try and open it for the desired operation. These permission-checking
functions are mostly intended for script-writing, where loose guarantees
are tolerated.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_324"></a></p>
<div align="left"><tt>(file-readable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_326"></a><div align="left"><tt>(file-writable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_328"></a><div align="left"><tt>(file-executable? <i>fname/fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are the logical negation of the 
preceding <tt>file-not-<tt>...</tt>?</tt> procedures.
Refer to them for a discussion of their problems and limitations.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_330"></a></p>
<div align="left"><tt>(file-info-not-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_332"></a><div align="left"><tt>(file-info-not-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_334"></a><div align="left"><tt>(file-info-not-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p></p>
<p></p>
<p><a name="node_idx_336"></a></p>
<div align="left"><tt>(file-info-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_338"></a><div align="left"><tt>(file-info-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_340"></a><div align="left"><tt>(file-info-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
There are variants which work directly on <tt>file-info</tt> records.</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_346"></a></p>
<div align="left"><tt>(directory-files <i>[dir dotfiles?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the list of files in directory <i>dir</i>, 
which defaults to the current working directory.
The <i>dotfiles?</i> flag (default <tt>#f</tt>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <tt>.</tt> and
<tt>..</tt> are <em>never</em> returned.<p>
The directory <i>dir</i> is not prepended to each file name in the
result list. That is, 
</p>
<blockquote><tt>(directory-files "/etc")</tt></blockquote>returns
<blockquote><tt>("chown" "exports" "fstab" <tt>...</tt>)</tt></blockquote><em>not</em>
<blockquote><tt>("/etc/chown" "/etc/exports" "/etc/fstab" <tt>...</tt>)</tt></blockquote>To use the files in returned list, the programmer can either manually
prepend the directory:
<blockquote><tt>(map (lambda (f) (string-append dir "/" f)) files)</tt></blockquote>or cd to the directory before using the file names:
<blockquote><tt><br>
(with-cwd&nbsp;dir<br>
&nbsp;&nbsp;(for-each&nbsp;delete-file&nbsp;(directory-files)))</tt></blockquote>
or use the <tt>glob</tt> procedure, defined below.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_348"></a></p>
<div align="left"><tt>(open-directory-stream <i>dir</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>directory-stream-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_350"></a></p>
<div align="left"><tt>(read-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_352"></a></p>
<div align="left"><tt>(close-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
These functions implement a direct interface to the
<tt>opendir()</tt>/
<tt>readdir()</tt>/
<tt>closedir()</tt>
family of functions for processing directory streams.
<tt>(open-directory-stream dir)</tt> creates a stream of files in the
directory <tt>dir</tt>. <tt>(read-directory-stream directory-stream)</tt>
returns the next file in the stream or <tt>#f</tt>if no such file exists.
Finally, <tt>(close-directory-stream directory-stream)</tt> closes the
stream.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_354"></a></p>
<div align="left"><tt>(glob <i><i>pat</i><sub>1</sub> <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Glob each pattern against the filesystem and return the sorted list. 
Duplicates are not removed. Patterns matching nothing are not included 
literally.<a name="node_call_footnote_5"></a><a href="#node_footnote_5"><sup><small>5</small></sup></a>
C shell <code class="verbatim">{a,b,c}</code> patterns are expanded. Backslash quotes 
characters, turning off the special meaning of
<code class="verbatim">{</code>, <code class="verbatim">}</code>, <tt>*</tt>, <code class="verbatim">[</code>, <code class="verbatim">]</code>, and <code class="verbatim">?</code>. <p>
Note that the rules of backslash for Scheme strings and glob patterns
work together to require four backslashes in a row to specify a
single literal backslash. Fortunately, it is very rare that a backslash
occurs in a Unix file name.</p>
<p>
A glob subpattern will not match against dot files unless the first
character of the subpattern is a literal "<tt>.</tt>". 
Further, a dot subpattern will not match the files <tt>.</tt> or <tt>..</tt> 
unless it is a constant pattern, as in <tt>(glob "../*/*.c")</tt>.
So a directory's dot files can be reliably generated
with the simple glob pattern <tt>".*"</tt>.</p>
<p>
Some examples:
</p>
<blockquote>
<pre class="verbatim">(glob "*.c" "*.h")
    ;; All the C and #include files in my directory.

(glob "*.c" "*/*.c")
    ;; All the C files in this directory and 
    ;; its immediate subdirectories.

(glob "lexer/*.c" "parser/*.c")
(glob "{lexer,parser}/*.c")
    ;; All the C files in the lexer and parser dirs.

(glob "\\{lexer,parser\\}/*.c")
    ;; All the C files in the strange 
    ;; directory "{lexer,parser}".

(glob "*\\*")
    ;; All the files ending in "*", e.g.
    ;; ("foo*" "bar*")         

(glob "*lexer*")
    ("mylexer.c" "lexer1.notes") 
    ;; All files containing the string "lexer".

(glob "lexer")
    ;; Either ("lexer") or ().</pre><p>
</p>
</blockquote>
If the first character of the pattern (after expanding braces) is a slash,
the search begins at root; otherwise, the search begins in the current
working directory.<p>
If the last character of the pattern (after expanding braces) is a slash,
then the result matches must be directories, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(glob&nbsp;"/usr/man/man?/")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("/usr/man/man1/"&nbsp;"/usr/man/man2/"&nbsp;<tt>...</tt>)</tt></blockquote><p>
Globbing can sometimes be useful when we need a list of a directory's files
where each element in the list includes the pathname for the file.
Compare:
</p>
<blockquote><tt><br>
(directory-files&nbsp;"../include")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;("cig.h"&nbsp;"decls.h"&nbsp;<tt>...</tt>)<br>
<br>
(glob&nbsp;"../include/*")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;("../include/cig.h"&nbsp;"../include/decls.h"&nbsp;<tt>...</tt>)</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_356"></a></p>
<div align="left"><tt>(glob-quote <i>str</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns a constant glob pattern that exactly matches <i>str</i>.
All wild-card characters in <i>str</i> are quoted with a backslash.
<blockquote><tt><br>
(glob-quote&nbsp;"Any&nbsp;*.c&nbsp;files?")<br>
&nbsp;&nbsp;&nbsp;&nbsp;==&gt;&nbsp;"Any&nbsp;\*.c&nbsp;files\?"</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_360"></a><div align="left"><tt>(create-temp-file <i>[prefix]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><tt>Create-temp-file</tt> creates a new temporary file and return its name.
The optional argument specifies the filename prefix to use, and defaults
to the value of <tt>"<tt>$TMPDIR</tt>/<i>pid</i>"</tt> if <tt>$TMPDIR</tt> is set and to
<tt>"/var/tmp/<i>pid</i>"</tt> otherwise, where <i>pid</i> is the current process' id.
The procedure generates a sequence of filenames that have <i>prefix</i> as
a common prefix, looking for a filename that doesn't already exist in the
file system. When it finds one, it creates it, with permission <tt>#o600</tt>
and returns the filename. (The file permission can be changed to a more
permissive permission with <tt>set-file-mode</tt> after being created).<p>
This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very
likely to be unused. It returns a filename that definitely did not exist
at the moment <tt>create-temp-file</tt> created it.</p>
<p>
It is not necessary for the process' pid to be a part of the filename
for the uniqueness guarantees to hold. The pid component of the default
prefix simply serves to scatter the name searches into sparse regions, so
that collisions are less likely to occur. This speeds things up, but does
not affect correctness.</p>
<p>
Security note: doing I/O to files created this way in <tt>/var/tmp/</tt> is
not necessarily secure. General users have write access to <tt>/var/tmp/</tt>,
so even if an attacker cannot access the new temp file, he can delete it
and replace it with one of his own. A subsequent open of this filename
will then give you his file, to which he has access rights. There are
several ways to defeat this attack,
</p>
<ol>
<li><p>Use <tt>temp-file-iterate</tt>, below, to return the file descriptor
allocated when the file is opened. This will work if the file
only needs to be opened once.
</p>
</li><li><p>If the file needs to be opened twice or more, create it in a 
protected directory, <em>e.g.</em>, <code class="verbatim">$HOME</code>.</p>
</li><li><p>Ensure that <tt>/var/tmp</tt> has its sticky bit set. This
requires system administrator privileges.
</p>
</li></ol><p>
The actual default prefix used is controlled by the parameter
<tt>*temp-file-template*</tt>, and can be overridden for increased security.
See <tt>temp-file-iterate</tt>.
</p>
</blockquote><p>
<a name="node_idx_362"></a></p>
<div align="left"><tt>(temp-file-iterate <i>maker [template]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i><sup>+</sup></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
                     
<a name="node_idx_364"></a><div align="left"><tt>*temp-file-template*</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string parameter</i>&nbsp;</div>
<blockquote>
This procedure can be used to perform certain atomic transactions on
the file system involving filenames. Some examples:
<ul>
<li><p>Linking a file to a fresh backup temp name.
</p>
</li><li><p>Creating and opening an unused, secure temp file.
</p>
</li><li><p>Creating an unused temporary directory.
</p>
</li></ul><p></p>
<p>
This procedure uses <i>template</i> to generate a series of trial
file names.  <i>Template</i> is a string, and
defaults to </p>
<blockquote><tt>"<tt>$TMPDIR</tt>/<i>pid</i>.~a"</tt></blockquote>if <tt>$TMPDIR</tt> is set
and <blockquote><tt>"/var/tmp/<i>pid</i>.~a"</tt></blockquote>otherwise where <i>pid</i> is
the current process' process id.  File names are generated by
concatenating <i>template</i>
with a varying string.<p>
<i>Maker</i> is a procedure which is serially called on each file name
generated.  It must return at least one value; it may return multiple
values. If the first return value is <tt>#f</tt> or if <i>maker</i> raises the
<tt>errno/exist</tt> errno exception, <tt>temp-file-iterate</tt> will loop,
generating a new file name and calling <i>maker</i> again. If the first
return value is true, the loop is terminated, returning whatever value(s)
<i>maker</i> returned.</p>
<p>
After a number of unsuccessful trials, <tt>temp-file-iterate</tt> may give up
and signal an error.</p>
<p>
Thus, if we ignore its optional <i>prefix</i> argument, 
<tt>create-temp-file</tt> could be defined as:
</p>
<blockquote><tt><br>
(define&nbsp;(create-temp-file)<br>
&nbsp;&nbsp;(let&nbsp;((flags&nbsp;(bitwise-ior&nbsp;open/create&nbsp;open/exclusive)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(temp-file-iterate&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(f)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close&nbsp;(open-output-file&nbsp;f&nbsp;flags&nbsp;#o600))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f))))</tt></blockquote><p>
To rename a file to a temporary name:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(create-hard-link&nbsp;old-file&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".#temp.~a")&nbsp;;&nbsp;Keep&nbsp;link&nbsp;in&nbsp;cwd.<br>
(delete-file&nbsp;old-file)</tt></blockquote>
Recall that SRFI reports syscall failure by raising an error
exception, not by returning an error code. This is critical to
to this example -- the programmer can assume that if the 
<tt>temp-file-iterate</tt> call returns, it returns successully.
So the following <tt>delete-file</tt> call can be reliably invoked,
safe in the knowledge that the backup link has definitely been established.<p>
To create a unique temporary directory:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(dir)&nbsp;(create-directory&nbsp;dir)&nbsp;dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/var/tmp/tempdir.~a")</tt></blockquote>
Similar operations can be used to generate unique symlinks and fifos,
or to return values other than the new filename (<em>e.g.</em>, an open file
descriptor or port).<p>
The default template is in fact taken from the value of the
dynamic variable <tt>*temp-file-template*</tt>, which itself defaults
to <tt>"<tt>$TMPDIR</tt>/<i>pid</i>.~a"</tt> if <tt>$TMPDIR</tt> is set and
<tt>"/usr/tmp/<i>pid</i>.~a"</tt> otherwise, where <i>pid</i> is the
SRFI process' pid.  For increased security, a user may wish to
change the template to use a directory not allowing world write
access (<em>e.g.</em>, his home directory).
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_366"></a></p>
<div align="left"><tt>(temp-file-channel<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[inp outp]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure can be used to provides an interprocess communications
channel with arbitrary-sized buffering.  It returns two values, an input
port and an output port, both open on a new temp file.  The temp file
itself is deleted from the Unix file tree before <tt>temp-file-channel</tt>
returns, so the file is essentially unnamed, and its disk storage is
reclaimed as soon as the two ports are closed.<p>
<tt>Temp-file-channel</tt> is analogous to <tt>port-pipe</tt> with two exceptions:
</p>
<ul>
<li><p>If the writer process gets ahead of the reader process, it will
not hang waiting for some small pipe buffer to drain. It will simply
buffer the data on disk. This is good.</p>
<p>
</p>
</li><li><p>If the reader process gets ahead of the writer process, it will
also not hang waiting for data from the writer process. It will
simply see and report an end of file. This is bad.</p>
<p>
In order to ensure that an end-of-file returned to the reader is
legitimate, the reader and writer must serialise their I/O. The
simplest way to do this is for the reader to delay doing input
until the writer has completely finished doing output, or exited.
</p>
</li></ul><p>
</p>
</blockquote><p>
</p>
<a name="node_sec_3.4"></a>
<h2><a href="#node_toc_node_sec_3.4">3.4&nbsp;&nbsp;Processes</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_368"></a></p>
<div align="left"><tt>(exec <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_370"></a><div align="left"><tt>(exec-path <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_372"></a><div align="left"><tt>(exec/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_374"></a><div align="left"><tt>(exec-path/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
The <tt><tt>...</tt>/env</tt> variants take an environment specified as a 
string--&gt;string alist.
An environment of <tt>#t</tt> is taken to mean the current process' environment 
(<em>i.e.</em>, the value of the external char <tt>**environ</tt>).</p>
<p>
The path-searching variants search the directories in the list 
<tt>exec-path-list</tt> for the program.
A path-search is not performed if the program name contains
a slash character -- it is used directly. So a program with a name like
<tt>"bin/prog"</tt> always executes the program <tt>bin/prog</tt> in the current working
directory. See <code class="verbatim">$path</code> and <code class="verbatim">exec-path-list</code>, below.</p>
<p>
Note that there is no analog to the C function <tt>execv()</tt>.
To get the effect just do
</p>
<blockquote><tt>(apply exec prog arglist)</tt></blockquote><p>
All of these procedures may flush buffered output.
<p>
Note that the C <tt>exec()</tt> procedure allows the zeroth element of the
argument vector to be different from the file being executed, <em>e.g.</em></p>
<blockquote>
<pre class="verbatim">char *argv[] = {"-", "-f", 0};
exec("/bin/csh", argv, envp);</pre><p>
</p>
</blockquote>
The SRFI <tt>exec</tt>, <tt>exec-path</tt>, <tt>exec/env</tt>, and <tt>exec-path/env</tt>
procedures do not give this functionality -- element 0 of the arg vector is
always identical to the <tt>prog</tt> argument. 
These procedures never return under any circumstances.
As with any other system call, if there is an error, they raise
an exception.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_idx_386"></a><div align="left"><tt>(suspend<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Suspend the current process with a SIGSTOP signal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_388"></a></p>
<div align="left"><tt>(fork <i>[thunk or <tt>#f</tt>] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_390"></a><div align="left"><tt>(%fork <i>[thunk or <tt>#f</tt>] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<tt>fork</tt> with no arguments or <tt>#f</tt> instead of a thunk is like
C
<tt>fork()</tt>.
In the parent process, it returns the child's <em>process object</em>
(see below for more information on process objects).  In the child
process, it returns <tt>#f</tt>.<p>
<tt>fork</tt> with an argument only returns in the parent process, returning
the child's process object.
The child process calls <i>thunk</i> and then exits.</p>
<p>
<tt>fork</tt> flushes buffered output before forking, and sets the child
process to non-interactive. <code class="verbatim">%fork</code> does not perform this bookkeeping;
it simply forks.</p>
<p>
The optional boolean argument <i>continue-threads?</i> specifies
whether the currently active threads continue to run in the child or
not.  The default is <tt>#f</tt>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_392"></a></p>
<div align="left"><tt>(fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_394"></a><div align="left"><tt>(%fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork</tt> and <tt>%fork</tt>, but the parent and child communicate via a
pipe connecting the parent's stdin to the child's stdout. These procedures
side-effect the parent by changing his stdin.<p>
In effect, <tt>fork/pipe</tt> splices a process into the data stream
immediately upstream of the current process.
This is the basic function for creating pipelines.
Long pipelines are built by performing a sequence of <tt>fork/pipe</tt> calls.
For example, to create a background two-process pipe <tt>a | b</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)&nbsp;(b)))</tt></blockquote>
which returns the process object for <tt>b</tt>'s process.<p>
To create a background three-process pipe <tt>a | b | c</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fork/pipe&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c)))</tt></blockquote>
which returns the process object for <tt>c</tt>'s process.<p>
Note that these procedures affect file descriptors, not ports.
That is, the pipe is allocated connecting the child's file descriptor
1 to the parent's file descriptor 0.
<em>Any previous Scheme port built over these affected file descriptors
is shifted to a new, unused file descriptor with <tt>dup</tt> before
allocating the I/O pipe.</em>
This means, for example, that the ports bound to <tt>(current-input-port)</tt>
and <tt>(current-output-port)</tt> in either process are not affected -- they 
still refer to the same I/O sources and sinks as before.
Remember the simple SRFI rule: Scheme ports are bound to I/O sources
and sinks, <em>not</em> particular file descriptors.</p>
<p>
If the child process wishes to rebind the current output port
to the pipe on file descriptor 1, it can do this using 
<tt>with-current-output-port</tt> or a related form.
Similarly, if the parent wishes to change the current input port
to the pipe on file descriptor 0, it can do this using
<tt>set-current-input-port!</tt> or a related form.
Here is an example showing how to set up the I/O ports on both sides
of the pipe:
</p>
<blockquote><tt><br>
(fork/pipe&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-current-output-port&nbsp;(fdes-&gt;outport&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"Hello,&nbsp;world.\n"))))<br>
<br>
(set-current-input-port!&nbsp;(fdes-&gt;inport&nbsp;0))<br>
(read-line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Read&nbsp;the&nbsp;string&nbsp;output&nbsp;by&nbsp;the&nbsp;child.</tt></blockquote>
None of this is necessary when the I/O is performed by an exec'd
program in the child or parent process, only when the pipe will
be referenced by Scheme code through one of the default current I/O
ports.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_396"></a></p>
<div align="left"><tt>(fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_398"></a><div align="left"><tt>(%fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork/pipe</tt>, but the pipe connections between the child and parent
are specified by the connection list <i>conns</i>. 
See the 
<blockquote><tt>(|+ <i>conns</i> <i>pf</i><sub>1</sub> <tt>...</tt> <i>pf</i><sub><em>n</em></sub>)</tt></blockquote>process form for a description of connection lists.
</blockquote><p>
</p>
<a name="node_sec_3.4.1"></a>
<h3><a href="#node_toc_node_sec_3.4.1">3.4.1&nbsp;&nbsp;Process objects and process reaping</a></h3>
<p>
This SRFI uses <em>process objects</em> to represent Unix processes.
They are created by the <tt>fork</tt> procedure, and 
are opaque objects wrapping the pid of the process, the integer id
assigned by the kernel to the process.
The only procedures for manipulating process objects
are <tt>proc?</tt> and <tt>proc-pid</tt>.
Process objects are created with the <tt>fork</tt> procedure.<p>
<i>Compatibility note: In Scsh,
<code>proc-pid</code> is spelled <i>proc:pid</i> in accordance with
Scheme48 conventions.</i></p>
<a name="node_sec_3.4.2"></a>
<h3><a href="#node_toc_node_sec_3.4.2">3.4.2&nbsp;&nbsp;Process waiting</a></h3>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_412"></a></p>
<div align="left"><tt>(wait <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>status</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure waits until a child process exits, and returns its
exit code. The <i>proc/pid</i> argument is either a process object
(section <a href="#node_sec_3.4.1">3.4.1</a>) or an integer process id.
<tt>Wait</tt> returns the child's exit status code (or suspension code,
if the <tt>wait/stopped-children</tt> option is used, see below).
Status values can be queried with the procedures in section 
<a href="#node_sec_3.4.3">3.4.3</a>.<p>
The <i>flags</i> argument is an integer whose bits specify
additional options. It is composed by or'ing together the following
flags:
</p>
<div align="center"><table><tbody><tr><td>

<table border="1"><tbody><tr><td valign="top">Flag                    </td><td valign="top">Meaning                           </td></tr>
<tr><td valign="top"><tt>wait/poll</tt>          </td><td valign="top">Return <tt>#f</tt> immediately if
child still active.               </td></tr>
<tr><td valign="top"><tt>wait/stopped-children</tt>      </td><td valign="top">Wait for suspend as well as exit. </td></tr>
<tr><td valign="top"></td></tr></tbody></table>
</td></tr></tbody></table></div>

</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_414"></a><div align="left"><tt>(wait-any <i>[flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The optional <i>flags</i> argument is as for <tt>wait</tt>.
This procedure waits for any child process to exit (or stop, if the
<tt>wait/stopped-children</tt> flag is used)
It returns the process' process object and status code.
If there are no children left for which to wait, the two values
<tt>[<tt>#f</tt> <tt>#t</tt>]</tt> are returned.
If the <tt>wait/poll</tt> flag is used, and none of the children
are immediately eligble for waiting, 
then the values <tt>[<tt>#f</tt> <tt>#f</tt>]</tt> are returned:
<div align="center"><table><tbody><tr><td>

<table border="1"><tbody><tr><td valign="top">[<tt>#f</tt> <tt>#f</tt>] </td><td valign="top">Poll, none ready </td></tr>
<tr><td valign="top">[<tt>#f</tt> <tt>#t</tt>] </td><td valign="top">No children      </td></tr>
<tr><td valign="top"></td></tr></tbody></table>
</td></tr></tbody></table></div>
<p>
<tt>Wait-any</tt> will not return a process that has been previously waited
by any other process-wait procedure (<tt>wait</tt>, <tt>wait-any</tt>,
and <tt>wait-process-group</tt>).
It will return reaped processes that haven't yet been waited.</p>
<p>
The use of <tt>wait-any</tt> is deprecated.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_416"></a><div align="left"><tt>(wait-process-group <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure waits for any child whose process group is <i>proc/pid</i>
(either a process object or a pid).
The <i>flags</i> argument is as for <tt>wait</tt>.<p>
Note that if the programmer wishes to wait for exited processes
by process group, the program should take care not to use process
reaping (section <a href="#node_sec_3.4.1">3.4.1</a>), as this loses
process group information. However, most process-group waiting is
for stopped processes (to implement job control), so this is rarely
an issue, as stopped processes are not subject to reaping.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.4.3"></a>
<h3><a href="#node_toc_node_sec_3.4.3">3.4.3&nbsp;&nbsp;Analysing process status codes</a></h3>
<p>
When a child process dies (or is suspended), its parent can call the <tt>wait</tt>
procedure to recover the exit (or suspension) status of the child.
The exit status is a small integer that encodes information
describing how the child terminated.
The bit-level format of the exit status is not defined by P<small>OSIX</small>;
you must use the following three functions to decode one.
However, if a child terminates normally with exit code 0,
P<small>OSIX</small> does require <tt>wait</tt> to return an exit status that is exactly
zero.
So <tt>(zero? <i>status</i>)</tt> is a correct way to test for non-error, 
normal termination, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(if&nbsp;(zero?&nbsp;(run&nbsp;(rcp&nbsp;SRFI.tar.gz&nbsp;lambda.csd.hku.hk:)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(delete-file&nbsp;"SRFI.tar.gz"))</tt></blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_418"></a></p>
<div align="left"><tt>(status:exit-val <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_420"></a><div align="left"><tt>(status:stop-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_422"></a><div align="left"><tt>(status:term-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
For a given status value produced by calling <tt>wait</tt>,
exactly one of these routines will return a true value.<p>
If the child process exited normally, <tt>status:exit-val</tt> returns the
exit code for the child process (<em>i.e.</em>, the value the child passed to <tt>exit</tt> 
or returned from <tt>main</tt>). Otherwise, this function returns false.</p>
<p>
If the child process was suspended by a signal, <tt>status:stop-sig</tt>
returns the signal that suspended the child.
Otherwise, this function returns false.</p>
<p>
If the child process terminated abnormally, <tt>status:term-sig</tt>
returns the signal that terminated the child.
Otherwise, this function returns false.
</p>
</blockquote><p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_3.5"></a>
<h2><a href="#node_toc_node_sec_3.5">3.5&nbsp;&nbsp;Process state</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_424"></a></p>
<div align="left"><tt>(umask<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_426"></a><div align="left"><tt>(set-umask <i>perms</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The process' current umask is retrieved with <tt>umask</tt>, and set with
<tt>(set-umask <i>perms</i>)</tt>. 
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_432"></a></p>
<div align="left"><tt>(chdir <i>[fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_434"></a><div align="left"><tt>(cwd<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These forms manipulate the current working directory.
The cwd can be changed with <tt>chdir</tt>.
If <tt>chdir</tt> is called with no arguments, it changes the cwd to
the user's home directory.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_440"></a></p>
<div align="left"><tt>(pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_442"></a><div align="left"><tt>(parent-pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_444"></a><div align="left"><tt>(process-group<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_446"></a><div align="left"><tt>(set-process-group <i>[proc/pid] pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>    
<tt>(pid)</tt> and <tt>(parent-pid)</tt> retrieve the process id for the 
current process and its parent.
<tt>(process-group)</tt> returns the process group of the current process.
A process' process-group can be set with <tt>set-process-group</tt>; 
the value <i>proc/pid</i> specifies the affected process. It may be either
a process object or an integer process id, and defaults to the current
process.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_idx_452"></a><div align="left"><tt>(nice <i>[proc/pid delta]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure sets the niceness value of a process.
The higher the niceness, the lower the effective priority.
</blockquote><p>
<a name="node_idx_454"></a></p>
<div align="left"><tt>(user-login-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_456"></a><div align="left"><tt>(user-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_458"></a><div align="left"><tt>(user-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_460"></a><div align="left"><tt>(user-supplementary-gids<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_462"></a><div align="left"><tt>(set-uid <i>uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_464"></a><div align="left"><tt>(set-gid <i>gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These routines get and set the effective and real user and group ids.    
The <tt>set-uid</tt> and <tt>set-gid</tt> routines correspond to the P<small>OSIX</small>
<tt>setgid()</tt> procedures.
</blockquote><p>
<a name="node_idx_466"></a></p>
<div align="left"><tt>(user-effective-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_468"></a><div align="left"><tt>(set-user-effective-uid <i><i>fixnum</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_470"></a><div align="left"><tt>(with-user-effective-uid* <i><i>fixnum</i> thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_472"></a><div align="left"><tt>(with-user-effective-uid <i><i>fixnum</i> . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<a name="node_idx_474"></a><div align="left"><tt>(user-effective-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>fixnum</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_476"></a><div align="left"><tt>(set-user-effective-gid <i><i>fixnum</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_478"></a><div align="left"><tt>(with-user-effective-gid* <i><i>fixnum</i> thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_480"></a><div align="left"><tt>(with-user-effective-gid <i><i>fixnum</i> . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>
<p>
</p>
<blockquote>
These forms manipulate the effective user/group IDs. Possible values
for setting this resource are either the real user/group ID or the
saved set-user/group-ID. The <tt>with-...</tt> forms perform the ususal
temprary assignment during the execution of the second argument. The
effective user and group IDs are thread-local.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_482"></a></p>
<div align="left"><tt>(process-times<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>fixnum</i> <i>fixnum</i> <i>fixnum</i> <i>fixnum</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns four values:
<blockquote>
<div align="left"><table><tbody><tr><td>

user CPU time in clock-ticks            <br>
system CPU time in clock-ticks          <br>
user CPU time of all descendant processes        <br>
system CPU time of all descendant processes
</td></tr></tbody></table></div>

</blockquote>
Note that CPU time clock resolution is not the same as 
the real-time clock resolution providesd by <tt>time+ticks</tt>.
That's Unix.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_484"></a></p>
<div align="left"><tt>(cpu-ticks/sec<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the resolution of the CPU timer in clock ticks per second.
This can be used to convert the times reported by <tt>process-times</tt>
to seconds.
</blockquote><p>
</p>
<a name="node_sec_3.6"></a>
<h2><a href="#node_toc_node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</a></h2>
<p>These procedures are used to access the user and group databases
(<em>e.g.</em>, the ones traditionally stored in <tt>/etc/passwd</tt> and <tt>/etc/group</tt>.)</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_486"></a></p>
<div align="left"><tt>(user-info <i>uid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>user-info</tt> record giving the recorded information for a
particular user:
<a name="node_idx_488"></a>
<a name="node_idx_490"></a>
<a name="node_idx_492"></a>
<a name="node_idx_494"></a>
<a name="node_idx_496"></a>
<a name="node_idx_498"></a>
<blockquote><tt><br>
(define-record&nbsp;user-info<br>
&nbsp;&nbsp;name&nbsp;uid&nbsp;gid&nbsp;home-dir&nbsp;shell)</tt></blockquote>
The <i>uid/name</i> argument is either an integer uid or a string user-name.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_500"></a></p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_504"></a></p>
<div align="left"><tt>(group-info <i>gid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>group-info</tt> record giving the recorded information for a
particular group:
<a name="node_idx_506"></a>
<a name="node_idx_508"></a>
<a name="node_idx_510"></a>
<a name="node_idx_512"></a>
<blockquote><tt><br>
(define-record&nbsp;group-info<br>
&nbsp;&nbsp;name&nbsp;gid&nbsp;members)</tt></blockquote>
The <i>gid/name</i> argument is either an integer gid or a string group-name.
</blockquote><p>
</p>
<a name="node_sec_3.7"></a>
<h2><a href="#node_toc_node_sec_3.7">3.7&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<a name="node_sec_3.8"></a>
<h2><a href="#node_toc_node_sec_3.8">3.8&nbsp;&nbsp;System parameters</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_524"></a></p>
<div align="left"><tt>(system-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns the name of the host on which we are executing.
This may be a local name, such as "solar," as opposed to a
fully-qualified domain name such as "solar.csie.ntu.edu.tw."
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_526"></a></p>
<div align="left"><tt>(uname<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>uname-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns a <em>uname-record</em> of the following structure:
<blockquote><tt><br>
(define-record&nbsp;uname<br>
&nbsp;&nbsp;&nbsp;os-name<br>
&nbsp;&nbsp;&nbsp;node-name<br>
&nbsp;&nbsp;&nbsp;release<br>
&nbsp;&nbsp;&nbsp;version<br>
&nbsp;&nbsp;&nbsp;machine)</tt></blockquote><p>
Each of the fields contains a string.</p>
<p>
Be aware that P<small>OSIX</small> limits the length of all entries to 32 characters,
and that the node name does not necessarily correspond to the
fully-qualified domain name.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.9"></a>
<h2><a href="#node_toc_node_sec_3.9">3.9&nbsp;&nbsp;Signal system</a></h2>
<p>Signal numbers are bound to the variables <tt>signal/hup</tt>, <tt>signal/int</tt>,
<tt>...</tt>. See tables&nbsp;<a href="#node_tbl_Temp_3">3.9.0.1</a> and 
<a href="#node_tbl_Temp_4">3</a> for the full list.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_528"></a></p>
<div align="left"><tt>(signal-process <i>proc sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_530"></a><div align="left"><tt>(signal-process-group <i>prgrp sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These two procedures send signals to a specific process, and all the processes
in a specific process group, respectively.
The <i>proc</i> and <i>prgrp</i> arguments are either processes 
or integer process ids.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_sec_3.9.0.1"></a>
<h4><a href="#node_toc_node_sec_3.9.0.1">3.9.0.1&nbsp;&nbsp;Interrupt handlers</a></h4>
<p>
<a name="node_idx_664"></a><div align="left"><tt>(set-signal-handler <i>signal handler</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>old-handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Assigns a handler for a given signal, 
and returns the signal's old handler.
The <i>handler</i> argument is <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an integer argument; 
the return value follows the same conventions.
It is an error to provide a procedure for a synchronous signal.
</p>
<p><i>Compatibility note: In Scsh this procedure is called
<code>set-interrupt-handler</code> and accepts an interrupt
value rather than a signal value.  The Scsh procedure
<code>signal-&gt;interrupt</code> converts its argument
from a signal value to an interrupt value.</i></p>
<a name="node_idx_666"></a><div align="left"><tt>(signal-handler <i>signal</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the handler for a given interrupt.
<p><i>Compatibility note: In Scsh the argument is an interrupt value, not a signal value.
Calling <code>signal-&gt;interrupt</code> on the signal value will provide
the expected value.</i>
</p>
A handler is either <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an integer argument.
</blockquote><p>
<p><a name="node_idx_668"></a></p>
<div align="left"><tt>(ignore-signal <i><i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_670"></a><div align="left"><tt>(handle-signal-default <i><i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The procedure <tt>ignore-signal</tt> tells the process to ignore the
given signal. The procedure <tt>handle-signal-default</tt> resets the
signal handler to the default handler.<p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.10"></a>
<h2><a href="#node_toc_node_sec_3.10">3.10&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<h2><a href="#node_toc_node_sec_3.11">3.11&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<a name="node_sec_3.12"></a>
<h2><a href="#node_toc_node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</a></h2>
<p></p>
<p>
</p>
<p>
Although P<small>OSIX</small> provides a complete set of routines for manipulating terminal
devices -- putting them in "raw" mode, changing and querying their
special characters, modifying their I/O speeds, and so forth,
now that terminal emulators have almost completely displaced
terminals, very little of this is useful except for directly
controlling serial-line hardware, which itself is increasingly rare.
Therefore, this SRFI provides only the functions that are still
in common use: the ability to turn echoing on and off, the
ability to suppress the recognition of interrupt, quit, and
suspend characters; and the ability to put a terminal into
raw mode, in which no characters are specially recognized.
</p>

<p><a name="node_idx_728"></a></p>
<div align="left"><tt>(tty? <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return true if the argument is a tty.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_730"></a></p>
<div align="left"><tt>(tty-file-name <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
Return the file-name of the tty.
</blockquote><p>
</p>
<p>The following procedures use <tt>dynamic-wind</tt> magic when executing
their <tt>thunk</tt> arguments; if the thunk's dynamic extent is escaped,
the action of the procedure is undone, but if the thunk's dynamic extent
is re-entered, the action of the procedure is re-enabled.</p>
<p><a name="node_idx_730a"></a></p>
<div align="left"><tt>(with-raw-mode <i>fd/port min time thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
The tty is set to raw mode during the dynamic execution of <tt>thunk</tt>
and then is restored to canonical ("cooked") mode.
</blockquote><p>
</p>
<p><a name="node_idx_730b"></a></p>
<div align="left"><tt>(without-echo <i>fd/port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
Echoing of input is disabled on the tty during the execution of <tt>thunk</tt>
and then is re-enabled.
</blockquote><p>
</p>
<p><a name="node_idx_730c"></a></p>
<div align="left"><tt>(without-interrupt-chars <i>fd/port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
The detection of interrupt (^C), quit (^\), and suspend (^Z) characters
on the tty is disabled during the execution of <tt>thunk</tt> and then is re-enabled.
</blockquote><p>
</p>
<p><a name="node_idx_786"></a></p>
<div align="left"><tt>(open-control-tty <i>tty-name [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure opens terminal device <i>tty-name</i> as the process'
control terminal 
(see the <tt>termios</tt> man page for more information on control terminals).
The <i>tty-name</i> argument is a file-name such as <tt>/dev/ttya</tt>.
The <i>flags</i> argument is a value suitable as the second argument
to the <tt>open-file</tt> call; it defaults to <tt>open/read+write</tt>, causing
the terminal to be opened for both input and output.<p>
The port returned is an input port if the <i>flags</i> permit it, 
otherwise an output port. 
R5RS/Scheme 48/SRFI do not have input/output ports,
so it's one or the other. 
However, you can get both read and write ports open on a terminal
by opening it read/write, taking the result input port,
and duping it to an output port with <tt>dup-&gt;outport</tt>.</p>
<p>
This procedure guarantees to make the opened terminal the
process' control terminal only if the process does not have
an assigned control terminal at the time of the call.
If the SRFI process already has a control terminal, the results are undefined.</p>
<p>
To arrange for the process to have no control terminal prior to calling
this procedure, use the <tt>become-session-leader</tt> procedure.</p>
<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_788"></a></p>
<div align="left"><tt>(become-session-leader<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This is the C <tt>setsid()</tt> call.
P<small>OSIX</small> job-control has a three-level hierarchy:
session/process-group/process. 
Every session has an associated control terminal.
This procedure places the current process into a brand new session,
and disassociates the process from any previous control terminal.
You may subsequently use <tt>open-control-tty</tt> to open a new control
terminal.<p>
It is an error to call this procedure if the current process is already
a process-group leader.
One way to guarantee this is not the case is only to call this procedure
after forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_790"></a></p>
<div align="left"><tt>(tty-process-group <i>fd/port/fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_792"></a><div align="left"><tt>(set-tty-process-group <i>fd/port/fname pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This pair of procedures gets and sets the process group of a given
terminal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_794"></a></p>
<div align="left"><tt>(control-tty-file-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the file-name of the process' control tty.
On every version of Unix of which we are aware, this is just the string
<tt>"/dev/tty"</tt>.
However, this procedure uses the official P<small>OSIX</small> interface, so it is more
portable than simply using a constant string.
</blockquote><p>
</p>
</p>
<p>
</p>
<p></p>
<div class="footnoterule"><hr></div><p></p>
<div class="footnote"><p><a name="node_footnote_3"></a><a href="#node_call_footnote_3"><sup><small>3</small></sup></a> Why not <tt>move-&gt;fdes</tt>? 
Because the current output port and error port
might be the same port.</p>
<p><a name="node_footnote_4"></a><a href="#node_call_footnote_4"><sup><small>4</small></sup></a> But see the note above</p>
<p><a name="node_footnote_5"></a><a href="#node_call_footnote_5"><sup><small>5</small></sup></a> Why bother to mention such a silly possibility?
Because that is what sh does.</p>
<p><a name="node_footnote_6"></a><a href="#node_call_footnote_6"><sup><small>6</small></sup></a> Also bound to Scheme 48 interrupt 
<a name="node_idx_540"></a><tt>interrupt/alarm</tt>.</p>
<p><a name="node_footnote_7"></a><a href="#node_call_footnote_7"><sup><small>7</small></sup></a> Also bound to Scheme 48 interrupt 
<a name="node_idx_546"></a><tt>interrupt/keyboard</tt>.</p>
<p><a name="node_footnote_8"></a><a href="#node_call_footnote_8"><sup><small>8</small></sup></a> Physics pedants please note:
The SRFI authors live in a Newtonian universe. We disclaim responsibility
for calculations performed in non-ANSI standard light-cones.</p>
<p><a name="node_footnote_9"></a><a href="#node_call_footnote_9"><sup><small>9</small></sup></a> <tt>...</tt>and hope the individual list elements 
don't contain colons themselves.</p>
<p><a name="node_footnote_10"></a><a href="#node_call_footnote_10"><sup><small>10</small></sup></a> 
Why? Because the length of the string varies from Unix to Unix.
For example, the word-erase control character (typically control-w)
is provided by most Unixes, but not part of the P<small>OSIX</small> spec.</p>
<p><a name="node_footnote_11"></a><a href="#node_call_footnote_11"><sup><small>11</small></sup></a> 
Note this is distinct from the SVR4-equivalent
<tt>ttyout/tab-delayx</tt> flag defined in 
table&nbsp;<a href="#node_tbl_Temp_9">7</a>.</p>
</div>
<p></p>
</div>


</body></html>
