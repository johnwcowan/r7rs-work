<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI FIXME: Host environment API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

  <body>

<h1>Title</h1>

Host environment API

<h1>Authors</h1>

Olin Shivers (original author), John Cowan (editor and shepherd)

<h1>Status</h1>


<h1>Abstract</h1>

<p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system within
which a Scheme program is executing. This SRFI specifies how the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all the
functions of this SRFI are available on all operating systems.
</p>

<h1>Issues</h1>

None at present.

<h1>Rationale</h1>

<p>The I/O and other environmental procedures provided by the various
Scheme standards were designed at a time when operating systems were far
more diverse than they are today, and therefore portability was difficult
or impossible to achieve.  In addition, Scheme has historically focused
on programming-language features rather than the practical needs of
mainstream software development.  Consequently, none of the standards
provide more than a limited set of operations.  Individual implementations
often provide much more, but in incompatible ways.</p>

<p>This SRFI uses P<small>OSIX</small> to provide maximally portable
access to the services of the operating system on which typical Scheme
implementations run.  Almost all operating systems today support all
or part of P<small>OSIX</small>, so the use of this SRFI is mostly
portable, but implementations are definitely not portable.  However,
an implementation of this SRFI can be layered over many existing
implementation-specific interfaces, or directly over a C FFI.  It is
even possible to implement it in part on top of the JVM or CLR virtual
machines.
</p>

<p>
This SRFI describes a specific P<small>OSIX</small> API for Scheme.
Rather than attempting to compromise between existing implementations,
the Scsh system call specification was chosen as a base document.
Consequently, this SRFI is a reduced version of
<a href="https://scsh.net/docu/html/man-Z-H-4.html#node_chap_3">Chapter 3, "System Calls"</a>
of version 0.6.7 of the <i>Scsh Reference Manual</i>.
The numbered headers are aligned with those used in the Reference Manual.
</p>
<p>
This SRFI makes no effort to provide all 81 headers, 1191 interfaces, and 51
data types of P<small>OSIX</small>.  Instead it provides a reasonable number of
highly portable system calls (many of them are even available on Windows)
with a set of wrappers to make them more Scheme-like.
</p>

<p>Networking operations are not provided by this SRFI: see
<a href="http://srfi.schemers.org/srfi-106/srfi-106.html">SRFI 106</a>.
Date and time operations will be provided by a future SRFI, as the
P<small>OSIX</small> date and time operations are irregular and awkward.
Access to command-line arguments and environment variables, as well
as provisions for exiting a process, are already provided by R7RS.
Facilities such as memory-mapped I/O, locales, syslog, System V message
queues, and pseudo-TTYs are considered specialized and out of scope;
future SRFIs may provide interfaces for them.</p>


<h1>Specification</h1>

<p>
Implementations of this SRFI on non-P<small>OSIX</small> systems, especially Windows,
must provide all the procedure names and syntax keywords.
However, if the specified action is not possible, the procedure should
either take no action and return some reasonable default value,
or raise an <tt>errno-error</tt> exception.
<p>
</p>
<a name="node_sec_3.1"></a>
<h2><a href="#node_toc_node_sec_3.1">3.1&nbsp;&nbsp;Errors</a></h2>
<p>This SRFI's procedures never return error codes, and do not use a global
<tt>errno</tt> variable to report errors.
Errors are consistently reported by raising exceptions.
This frees up the procedures to return useful values,
and allows the programmer to assume that 
<em>if a procedure returns, it succeeded.</em>
This greatly simplifies the flow of the code from the programmer's point
of view.</p>
<p>
The tiny exception system documented here can either be implemented stand-alone
with clever use of
<tt>call/cc</tt>, or else as a simple sugaring over an R6RS/R7RS-style exception system.
For reference purposes, the P<small>OSIX</small> <tt>errno</tt> numbers 
are bound to the variables <tt>errno/perm</tt>, <tt>errno/noent</tt>, etc.
See <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html">
the P<small>OSIX</small> specification of <tt>errno.h</tt></a> for the complete list.
</p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_68"></a><div align="left"><tt>(errno-error <i>errno procedure . data</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Raises a non-continuable exception for P<small>OSIX</small> error number <i>errno</i>.
The <i>procedure</i> and <i>data</i> arguments are packaged up in the exception
packet passed to the exception handler.
</blockquote><p>
<a name="node_idx_70"></a></p>
<a name="node_idx_72"></a><div align="left"><tt>(with-errno-handler <i>handler-spec . body</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>value&nbsp;of&nbsp;body</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>
<blockquote>
Procedures raise error exceptions by calling <tt>errno-error</tt>.
Programs can use <tt>with-errno-handler</tt> to establish
handlers for these exceptions.
The <i>handler-spec</i> is a list whose car is a lambda list with two variables
and whose cdr is a list of <i>clauses</i>.
</p>
This form executes the body forms with a particular handler installed.
If <tt>errno-error</tt> is invoked, the handler search machinery will
bind the first variable to the error's integer code, and the second variable
to the error's auxiliary data packet, which
is a list of the form
<tt>(<i>errno-msg</i> <i>procedure</i> . <i>data</i>)</tt>,
where <i>errno-msg</i> is the standard P<small>OSIX</small> error message for the error,
<i>procedure</i> is the procedure that generated the error,
and   <i>data</i> is a list of information generated by the error,
which varies from procedure to procedure.</p>
<p>Then, the clauses will be checked for a match.
The first clause that matches is executed, and its value is the
value of the entire <tt>with-errno-handler</tt> form.
If no clause matches, the handler search continues.<p>
Error clauses have two forms:
</p>
<blockquote><tt><br>
((<i>errno</i>&nbsp;<tt>...</tt>)&nbsp;<i>body</i>&nbsp;<tt>...</tt>)<br>
(else&nbsp;<i>body</i>&nbsp;<tt>...</tt>)</tt></blockquote>
In the first type of clause, the <i>errno</i> forms are integer expressions.
They are evaluated and compared to the error's errno value.
An <tt>else</tt> clause matches any errno value. 
Note that the <i>errno</i> and <i>data</i>
variables are lexically visible to the error clauses.<p>
Example:
</p>
<blockquote><tt>&nbsp;&nbsp;&nbsp;&nbsp;<br>
(with-errno-handler&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;((errno&nbsp;packet)&nbsp;;&nbsp;Only&nbsp;handle&nbsp;3&nbsp;particular&nbsp;errors.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/wouldblock&nbsp;errno/again)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((errno/acces)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(format&nbsp;#t&nbsp;"Not&nbsp;allowed&nbsp;access!")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f))<br>
<br>
&nbsp;&nbsp;(foo&nbsp;frobbotz)<br>
&nbsp;&nbsp;(blatz&nbsp;garglemumph))</tt></blockquote>
It is not defined what dynamic context the handler executes in.
<p>
Note that the procedures of this SRFI always retry when interrupted, so that
the <tt>errno/intr</tt> exception is never raised.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.2"></a>
<h2><a href="#node_toc_node_sec_3.2">3.2&nbsp;&nbsp;I/O</a></h2>
<p></p>
<a name="node_sec_3.2.1"></a>
<h3><a href="#node_toc_node_sec_3.2.1">3.2.1&nbsp;&nbsp;Standard R5RS I/O procedures</a></h3>
<a name="node_sec_3.2.2"></a>
<p>This SRFI recommends, but does not require, that implementors modify 
their implementations of standard Scheme
I/O procedures to accept P<small>OSIX</small> file descriptors (integers) wherever a
port argument is expected.  See below.</p>
<h3><a href="#node_toc_node_sec_3.2.2">3.2.2&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.3"></a>
<h3><a href="#node_toc_node_sec_3.2.3">3.2.3&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.4"></a>
<h3><a href="#node_toc_node_sec_3.2.4">3.2.4&nbsp;&nbsp;Ports and file descriptors</a></h3>
<p>
Dealing with P<small>OSIX</small> file descriptors in a Scheme environment is difficult. 
In P<small>OSIX</small>, open files are part of the process environment, and are referenced
by small integers called <em>file descriptors</em>. Open file descriptors are
the fundamental way I/O redirections are passed to subprocesses, since
file descriptors are preserved across fork's and exec's.</p>
<p>
Scheme, on the other hand, uses ports for specifying I/O sources. Ports are
garbage-collected Scheme objects, not integers. 
When a port is garbage collected, it is also closed. Because file
descriptors are just integers, it's impossible to garbage collect them &mdash; you
wouldn't be able to close file descriptor 3 unless there were no 3's in the
system, and you could further prove that your program would never again
compute a 3. This is difficult at best.</p>
<p>
If a Scheme program only used Scheme ports, and never actually used
file descriptors, this would not be a problem. But Scheme code
must descend to the file descriptor level in at least two circumstances:
when interfacing to foreign code, and
when interfacing to a subprocess.
</p><p>
This causes a problem. Suppose we have a Scheme port constructed
on top of file descriptor 3. We intend to fork off a program that
will inherit this file descriptor. If we drop references to the port,
the garbage collector may prematurely close file 3 before we fork
the subprocess. The interface described below is intended to fix this and 
other problems arising from the mismatch between ports and file descriptors.</p>
<p>
Unfortunately, there is no even vaguely portable solution to this problem.
Scsh and Guile undertake heroic measures to 
open new file descriptors for ports when the old file descriptors are
repurposed for something else, and to track when closing a port implies
closing its file descriptor or not.
But doing so involves more
changes than an implementation should have to make in order
to provide this SRFI.</p>

<p>Consequently, care must be taken when accessing a Scheme port through
its file descriptor.  If the program does not maintain a reference to the
port, the file descriptor may be closed when the port is garbage collected.
In the same way, if a file descriptor is duplicated with <code>dup2()</code>
and that file descriptor happens to be in use by an open port, 
it is an error to perform further operations on that port.</p>
<p>The following routines allow conversion between ports and file
descriptors.</p>
<p><a name="node_idx_114"></a></p>
<div align="left"><tt>(fdes-&gt;binary-input-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_116"></a><div align="left"><tt>(fdes-&gt;textual-output-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_116"></a><div align="left"><tt>(fdes-&gt;binary-output-port <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>These wrap a newly created port around the specified file descriptor.</p>
<p><i>Compatibility note: Scsh provides only <code>fdes->inport</code> and
<code>fdes->outport</code>, as it does not distinguish between
textual and binary ports.</i></p>
</blockquote>

<a name="node_idx_118"></a><div align="left"><tt>(port-&gt;fdes <i>port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This exposes the file descriptor of a port,
or <tt>#f</tt> if it has none (a string port, e.g.)
</blockquote><p>
</p>
<a name="node_sec_3.2.5"></a>
<h3><a href="#node_toc_node_sec_3.2.5">3.2.5&nbsp;&nbsp;[Intentionally omitted]</a></h3>
<a name="node_sec_3.2.6"></a>
<h3><a href="#node_toc_node_sec_3.2.6">3.2.6&nbsp;&nbsp;P<small>OSIX</small> I/O</a></h3>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_128"></a></p>
<a name="node_idx_134"></a><div align="left"><tt>(dup-&gt;fdes <i>fd/port [newfd]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>fd</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure provides the functionality of the P<small>OSIX</small>
<code>dup()</code> and <code>dup2()</code> functions.
These procedures use the P<small>OSIX</small> <tt>dup()</tt> procedure to replicate
the file descriptor or file port <i>fd/port</i>.
If a <i>newfd</i> file descriptor is given, it is used as the target of
the dup operation, i.e., the operation is a <tt>dup2()</tt>.
<p>
If the <i>newfd</i> target is given, 
and some port is already using that file descriptor,
it is an error to perform further operations on that port.</p>
</blockquote>
<p></p>
<p></p>
<p><a name="node_idx_136"></a></p>
<div align="left"><tt>(seek <i>fd/port offset [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Reposition the I/O cursor for a file descriptor or port.
<i>whence</i> is one of {<tt>seek/set</tt>, <tt>seek/delta</tt>, <tt>seek/end</tt>},
and defaults to <tt>seek/set</tt>.
If <tt>seek/set</tt>, then <i>offset</i> is an absolute index into the file;
if <tt>seek/delta</tt>, then <i>offset</i> is a relative offset from the current
I/O cursor;
if <tt>seek/end</tt>, then <i>offset</i> is a relative offset from the end of file.
All offsets are measured in bytes.
The <i>fd/port</i> argument may be a port or an exact integer file descriptor.
Not all such values are seekable;
this is dependent on the OS implementation.
The return value is the resulting position of the I/O cursor in the I/O stream.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_138"></a></p>
<div align="left"><tt>(tell <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the position of the I/O cursor in the the I/O stream.
Not all file descriptors or ports support cursor-reporting; 
this is dependent on the OS implementation.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_140"></a><div align="left"><tt>(open-file <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>port</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<i>Perms</i> defaults to <tt>#o666</tt>.
<i>Flags</i> is an exact integer bitmask, composed by adding together the following constants:
<tt>open/read</tt>, <tt>open/write</tt>, <tt>open/read+write</tt>
(only one of these three may be provided),
<tt>open/append</tt>, <tt>open/non-blocking</tt>,
<tt>open/create</tt>, <tt>open/exclusive</tt>,
<tt>open/no-control-tty</tt>, <tt>open/truncate</tt>.
In addition, the flags <tt>open/text</tt> and <tt>open/binary</tt>
are used to control whether a textual or a binary port is returned,
but are not passed to <tt>open()</tt> except on Windows.</p>
<p>
The returned port is an input port if the <i>flags</i> permit it, 
otherwise an output port. 
You can hack simultaneous
I/O on a file by opening it r/w, taking the result input port, 
and duping it to an output port with <tt>dup-fdes</tt>.)
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_142"></a></p>
<p></p>
<p></p>
<a name="node_idx_146"></a><div align="left"><tt>(open-fdes <i>fname flags [perms]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns a file descriptor instead of a port.
</blockquote><p>
</p>
<p></p>
<div align="left"><tt>(close-fdes <i>fd</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>undefined</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p></p>
<blockquote>
<p>Closes the file descriptor <i>fd</i>.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_156"></a><div align="left"><tt>(pipe<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>rport</i> <i>wport</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns two ports, the read and write end-points of a P<small>OSIX</small> pipe.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_170"></a></p>
<div align="left"><tt>(select-ports <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The <tt>select-ports</tt> call will block until at least one of the
ports passed to it is ready for operation or until the timeout has
expired.  For an input port this means that it either has data
sitting its buffer or that the underlying file descriptor has data
waiting.  For an output port this means that it either has space
available in the associated buffer or that the underlying file
descriptor can accept output.<p>
The <i>timeout</i> value can be used to force the call to time out
after a given number of seconds.  A value of <tt>#f</tt> means to wait
indefinitely.  A zero value can be used to poll the ports.</p>
<p>
<tt>Select-ports</tt> returns a list of the ports ready for
operation.  Note that this list may be empty if the timeout expired
before any ports became ready.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_172"></a></p>
<div align="left"><tt>(select-port-channels <i>timeout port <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>ready-ports</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
<tt>Select-port-channels</tt> is like <tt>select-ports</tt>, except
that it only looks at the operating system objects the ports refer
to, ignoring any buffering performed by the ports.<p>
</p>
<blockquote><i>Remark: </i> <tt>Select-port-channels</tt> should be used with care: for
example, if an input port has data in the buffer but no data
available on the underlying file descriptor,
<tt>select-port-channels</tt> will block, even though a read
operation on the port would be able to complete without blocking.<p>
<tt>Select-port-channels</tt> is intended for situations where the
program is not checking for available data, but rather for waiting
until a port has established a connection &mdash; for example, to a
network port.</p>
</blockquote>
</blockquote><p>
</p>
<a name="node_sec_3.2.7"></a>
<h3><a href="#node_toc_node_sec_3.2.7">3.2.7&nbsp;&nbsp;Buffered I/O</a></h3>
<p>In most Scheme implementations, ports use buffered I/O &mdash; data is transferred to or from the
OS in blocks. This SRFI provides control of this mechanism: the programmer
may force saved-up output data to be transferred to the OS when
he chooses, 
and may also choose which I/O buffering policy to employ for a given
port (or turn buffering off completely). </p>
<a name="node_idx_178"></a><div align="left"><tt>(set-port-buffering <i>port policy [size]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure allows the programmer to assign a particular I/O buffering
policy to a port, and to choose the size of the associated buffer.
It may only be used on new ports, i.e., before I/O is performed on the port.
There are three buffering policies that may be chosen:
<blockquote>
<table border="0"><tbody><tr><td valign="top"><a name="node_idx_180"></a><tt>bufpol/block</tt> </td><td valign="top">General block buffering (general default) </td></tr>
<tr><td valign="top"><a name="node_idx_182"></a><tt>bufpol/line</tt>  </td><td valign="top">Line buffering (tty default) </td></tr>
<tr><td valign="top"><a name="node_idx_184"></a><tt>bufpol/none</tt>  </td><td valign="top">Direct I/O &mdash; no buffering<a name="node_call_footnote_4"></a><a href="#node_footnote_4"><sup><small>4</small></sup></a>
</td></tr></tbody></table>
</blockquote>
The line buffering policy flushes output whenever a newline is output;
whenever the buffer is full; or whenever an input is read from stdin.
Line buffering is the default for ports open on terminal devices.
The <i>size</i> argument requests an I/O buffer of <i>size</i> bytes.
For output ports, <i>size</i> must be non-negative, for input ports
<i>size</i> must be positve. If not given, a reasonable default is
used. For output ports, if given and zero, buffering is turned off
(i.e., <i>size</i>  =  0 for any policy is equivalent to <i>policy</i>  = 
<tt>bufpol/none</tt>). For input ports, setting the size to one
corresponds to unbuffered input as defined above. If given, <i>size</i>
must be zero respectively one for <tt>bufpol/none</tt>.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_sec_3.2.8"></a>
<h3><a href="#node_toc_node_sec_3.2.8">3.2.8&nbsp;&nbsp;File locking</a></h3>
<p>
This SRFI provides P<small>OSIX</small> advisory file locking.
<em>Advisory</em> locks are locks that can be checked by user code, 
but do not affect other I/O operations.
For example, if a process has an exclusive lock on a region of a file,
other processes will not be able to obtain locks on that region of the file,
but they will still be able to read and write the file with no hindrance.
Using advisory locks requires cooperation amongst the agents accessing
the shared resource.</p>
<p>
</p>
<blockquote><i>Remark: </i> 
Unfortunately, P<small>OSIX</small> file locks are associated with actual files,
not with associated open file descriptors.
Once a process locks a file, using some file descriptor <i>fd</i>,
the next time <em>any</em> file descriptor referencing that file is closed, 
all associated locks are released.
This severely limits the utility of P<small>OSIX</small> advisory file locks,
and we'd recommend caution when using them.
It is not without reason that the FreeBSD man pages refer to P<small>OSIX</small>
file locking as "completely stupid."<p>
This means the file-locking procedures can then be applied to the port's
associated file descriptor.
</p>
</blockquote><p>
P<small>OSIX</small> allows the user to lock a region of a file with either 
an exclusive or shared lock.
Locked regions are described by the <em>lock-region</em> record.
</p>
<div align="left"><tt>(lock-region? <i>obj</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if <i>obj</i> is a lock-region and <tt>#f</tt> otherwise.</blockquote>
<div align="left"><tt>(lock-region:exclusive? <i>lock-region</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if the lock is exclusive and <tt>#f</tt>.
if it is shared.</blockquote>
<div align="left"><tt>(lock-region:start <i>lock-region</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the start byte of the locked region.</blockquote>
<div align="left"><tt>(lock-region:len <i>lock-region</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the length of the locked region.
if it is zero, it means "infinity," that is, the region extends
from the starting point through the end of the file, even as the file is
extended by subsequent write operations.</p>
</blockquote>
<div align="left"><tt>(lock-region:whence <i>lock-region</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns one of the values from the <tt>seek</tt> call:
<tt>seek/set</tt>, <tt>seek/delta</tt>, or <tt>seek/end</tt>, 
and determines the interpretation of the <tt>start</tt> field in the same way.
</blockquote>
<p>
</p>
<div align="left"><tt>(lock-region:proc <i>lock-region</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>procedure object</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the process object for the process holding the region
lock, when relevant (see <tt>get-lock-region</tt> below).
</blockquote>
</p>
</li></ul><p></p>
<p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_204"></a><div align="left"><tt>(make-lock-region <i>exclusive? start len [whence]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure makes a lock-region record. 
The <tt>whence</tt> field defaults to <tt>seek/set</tt>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_206"></a></p>
<div align="left"><tt>(lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_208"></a><div align="left"><tt>(lock-region/no-block <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
These procedures lock a region of the file referenced by file descriptor
<i>fdes</i>.
The <tt>lock-region</tt> procedure blocks until the lock is granted;
the non-blocking variant returns a boolean indicating whether or not
the lock was granted.
To take an exclusive (write) lock, you must have the file descriptor
open with write access;
to take a shared (read) lock, you must have the file descriptor
open with read access.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_210"></a><div align="left"><tt>(get-lock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>lock-region or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the first lock region on <i>fdes</i> that would conflict with 
lock region <i>lock</i>.
If there is no such lock region, return false.
This procedure fills out the <tt>proc</tt> field of the returned lock region,
and is the only procedure that has anything to do with this field.
(See section&nbsp;<a href="#node_sec_3.4.1">3.4.1</a> for a description of process objects.)
Note that if you apply this procedure to a file system that is shared
across multiple operating systems (i.e., an NFS file system), the <tt>proc</tt>
field may be ambiguous.
We note, again, that P<small>OSIX</small> advisory file locking is not a terribly useful
or well-designed facility.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_212"></a><div align="left"><tt>(unlock-region <i>fdes lock</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Release a lock from a file.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_214"></a></p>
<div align="left"><tt>(with-region-lock* <i>fdes lock thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of thunk</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_216"></a><div align="left"><tt>(with-region-lock <i>fdes lock body <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>value(s) of body</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax)&nbsp;</div>

<blockquote>
This procedure obtains the requested lock, and then calls 
<tt>(<i>thunk</i>)</tt>. When <i>thunk</i> returns, the lock is released.
A non-local exit (<em>e.g.</em>, throwing to a saved continuation or raising
an exception) also causes the lock to be released.<p>
After a normal return from <i>thunk</i>, its return values are returned
by <tt>with-region-lock*</tt>.
The <tt>with-region-lock</tt> syntax is equivalent sugar.
</p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.3"></a>
<h2><a href="#node_toc_node_sec_3.3">3.3&nbsp;&nbsp;File system</a></h2>
<p>The following procedures allow access to the
computer's file system.
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_218"></a></p>
<div align="left"><tt>(create-directory <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_220"></a><div align="left"><tt>(create-fifo <i>fname [perms override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_222"></a><div align="left"><tt>(create-hard-link <i>oldname newname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_224"></a><div align="left"><tt>(create-symlink <i>oldname newname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
These procedures create objects of various kinds in the file system.</p>
<p>
The <i>override?</i> argument controls the action if there is already an
object in the file system with the new name:
</p>
<blockquote><table border="0"><tbody><tr><td valign="top"><tt>#f</tt></td><td valign="top">signal an error (default) </td></tr>
<tr><td valign="top"><tt>#t</tt></td><td valign="top">
delete the old object (with <tt>delete-file</tt>
or <tt>delete-directory,</tt> as appropriate) before
creating the new object.<p>
</p>
</td></tr></tbody></table></blockquote><p>
<i>Perms</i> defaults to <tt>#o777</tt> (but is masked by the current umask).</p>
<p>
</p>
<blockquote><i>Remark: </i> Currently, if you try to create a hard or symbolic link 
and <i>oldname</i> and <i>newname</i> refer to the same file, it is an error
(and your file may be destroyed).
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_226"></a></p>
<div align="left"><tt>(delete-directory <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>This procedure deletes directories from the file system.
</p>
</blockquote><p>
</p>
<a name="node_idx_232"></a><div align="left"><tt>(read-symlink <i>fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Return the filename referenced by symbolic link <tt>fname</tt>.
</blockquote><p>
</p>
<a name="node_idx_234"></a><div align="left"><tt>(rename-file <i>oldname newname [override?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>If you override an existing object, then <i>oldname</i> 
and <i>newname</i> must type-match &mdash; either both directories, 
or both non-directories. 
This is required by the semantics of P<small>OSIX</small> <tt>rename()</tt>.<p>
</p>
<blockquote><i>Remark: </i> 
There is an unfortunate atomicity problem with the <tt>rename-file</tt> 
procedure: if you
specify no-override, but create file <tt>newname</tt> sometime between
<tt>rename-file</tt>'s existence check and the actual rename operation,
your file will be clobbered with <tt>oldname</tt>. There is no way to fix
this problem, given the semantics of P<small>OSIX</small> <tt>rename()</tt>; 
at least it is highly unlikely to occur in practice.
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_236"></a></p>
<div align="left"><tt>(set-file-mode <i>fname/fd/port mode</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_238"></a><div align="left"><tt>(set-file-owner <i>fname/fd/port uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_240"></a><div align="left"><tt>(set-file-group <i>fname/fd/port gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>    
These procedures set the permission bits, owner id, and group id of a
file, respectively.
The file can be specified by giving the file name, or either an
integer file descriptor or a port open on the file.
Setting file user ownership usually requires root privileges.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_242"></a></p>
<div align="left"><tt>(set-file-times <i>fname [access-time mod-time]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure sets the access and modified times for the file
<i>fname</i> to the supplied values (see section&nbsp;<a href="#node_sec_3.10">3.10</a>
for this SRFI's representation of time).
If neither time argument is supplied, they are both taken to be
the current time. You must provides both times or neither.
If the procedure completes successfully, the file's time of last
status-change (<tt>ctime</tt>) is set to the current time.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_244"></a></p>
<div align="left"><tt>(sync-file <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_246"></a><div align="left"><tt>(sync-file-system<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Calling <tt>sync-file</tt>
causes P<small>OSIX</small> to update the disk data structures for a given file.
If <i>fd/port</i> is a port, any buffered data it may have is first
flushed. 
Calling <tt>sync-file-system</tt> synchronises the kernel's entire file
system with the disk.<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_248"></a><div align="left"><tt>(truncate-file <i>fname/fd/port len</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>The specified file is truncated to <i>len</i> bytes in length.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_250"></a><div align="left"><tt>(file-info <i>fname/fd/port [chase?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>file-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The <tt>file-info</tt> procedure
returns a file-info record containing everything
there is to know about a file. If the <i>chase?</i> flag is true
(the default), then the procedure chases symlinks and reports on
the files to which they refer. If <i>chase?</i> is false, then 
the procedure checks the actual file itself, even if it's a symlink.
The <i>chase?</i> flag is ignored if the file argument is a file descriptor
or port.<p>
</blockquote>
<div align="left"><tt>(file-info? <i>obj</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if <i>obj</i> is a file-info object and <tt>#f</tt> otherwise.
</blockquote>

<div align="left"><tt>(file-info:device <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the device number stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:inode <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the inode number stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:mode <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the file mode stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:nlinks <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the number of hard links stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:uid <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the uid representing the file owner stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:gid <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the gid representing the file owner stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:size <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the file size in bytes stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:atime <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the file access time stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:mtime <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the file modification time stored in <i>file-info</i>.</blockquote>
<div align="left"><tt>(file-info:ctime <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the file last-status-change time stored in <i>file-info</i>.</blockquote>

</blockquote>
<table border="0"><tbody><tr><td valign="top"></td></tr></tbody></table>
</blockquote>
<p></p>
<p><a name="node_idx_306"></a></p>
<div align="left"><tt>(file-info-directory? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_308"></a><div align="left"><tt>(file-info-fifo? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_310"></a><div align="left"><tt>(file-info-regular? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_312"></a><div align="left"><tt>(file-info-socket? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_314"></a><div align="left"><tt>(file-info-special? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_316"></a><div align="left"><tt>(file-info-symlink? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are file-type predicates that test the
file type stored in a file-info record.
</blockquote>
<p>
The following set of procedures are a convenient means to investigate the
permission bits stored in a file-info record:</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_318"></a></p>
<div align="left"><tt>(file-info-not-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_320"></a><div align="left"><tt>(file-info-not-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_322"></a><div align="left"><tt>(file-info-not-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns:
<blockquote><table border="0"><tbody><tr><td valign="top">Value      </td><td valign="top">meaning </td></tr>
<tr><td valign="top"><tt>#f</tt></td><td valign="top">Access permitted </td></tr>
<tr><td valign="top">'search-denied          </td><td valign="top"><table border="0"><tbody><tr><td valign="top">Can't stat &mdash; a protected directory </td></tr>
<tr><td valign="top">is blocking access.</td></tr></tbody></table> </td></tr>
<tr><td valign="top">'permission             </td><td valign="top">Permission denied. </td></tr>
<tr><td valign="top">'no-directory           </td><td valign="top">Some directory doesn't exist. </td></tr>
<tr><td valign="top">'nonexistent            </td><td valign="top">File doesn't exist.
</td></tr></tbody></table></blockquote>
A file is considered writeable if either (1) it exists and is writeable
or (2) it doesn't exist and the directory is writeable.
Since symlink permission bits are ignored by the filesystem, these
calls do not take a <i>chase?</i> flag.<p>
Note that these procedures use the process' <em>effective</em> user
and group ids for permission checking. P<small>OSIX</small> defines an <tt>access()</tt>
function that uses the process' real uid and gids. This is handy
for setuid programs that would like to find out if the actual user
has specific rights; SRFI ought to provides this functionality (but doesn't
at the current time). </p>
<p>
There are several problems with these procedures. First, there's an
atomicity issue. In between checking permissions for a file and then trying
an operation on the file, another process could change the permissions,
so a return value from these functions guarantees nothing. Second, 
the code special-cases permission checking when the uid is root &mdash; if
the file exists, root is assumed to have the requested permission.
However, not even root can write a file that is on a read-only file system,
such as a CD ROM. In this case, <tt>file-not-writable?</tt> will lie, saying
that root has write access, when in fact the opening the file for write
access will fail.
Finally, write permission confounds write access and create access.
These should be disentangled.</p>
<p>
Some of these problems could be avoided if P<small>OSIX</small> had a real-uid
variant of the <tt>access()</tt> call we could use, but the atomicity
issue is still a problem. In the final analysis, the only way to
find out if you have the right to perform an operation on a file
is to try and open it for the desired operation. These permission-checking
functions are mostly intended for script-writing, where loose guarantees
are tolerated.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_324"></a></p>
<div align="left"><tt>(file-info-readable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_326"></a><div align="left"><tt>(file-info-writable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_328"></a><div align="left"><tt>(file-info-executable? <i>file-info</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These procedures are the logical negation of the 
preceding <tt>file-info-not-<tt>...</tt>?</tt> procedures.
Refer to them for a discussion of their problems and limitations.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_346"></a></p>
<div align="left"><tt>(directory-files <i>[dir dotfiles?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the list of files in directory <i>dir</i>, 
which defaults to the current working directory.
The <i>dotfiles?</i> flag (default <tt>#f</tt>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <tt>.</tt> and
<tt>..</tt> are <em>never</em> returned.<p>
The directory <i>dir</i> is not prepended to each file name in the
result list. That is, 
</p>
<blockquote><tt>(directory-files "/etc")</tt></blockquote>returns
<blockquote><tt>("chown" "exports" "fstab" <tt>...</tt>)</tt></blockquote><em>not</em>
<blockquote><tt>("/etc/chown" "/etc/exports" "/etc/fstab" <tt>...</tt>)</tt></blockquote>To use the files in returned list, the programmer can either manually
prepend the directory:
<blockquote><tt>(map (lambda (f) (string-append dir "/" f)) files)</tt></blockquote>or cd to the directory before using the file names:
<blockquote><tt><br>
(with-cwd&nbsp;dir<br>
&nbsp;&nbsp;(for-each&nbsp;delete-file&nbsp;(directory-files)))</tt></blockquote>
or use the <tt>glob</tt> procedure, defined below.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_348"></a></p>
<div align="left"><tt>(open-directory-stream <i>dir</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>directory-stream-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_350"></a></p>
<div align="left"><tt>(read-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p></p>
<p></p>
<p><a name="node_idx_352"></a></p>
<div align="left"><tt>(close-directory-stream <i>directory-stream-record</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<p>
These functions implement a direct interface to the
<tt>opendir()</tt>/
<tt>readdir()</tt>/
<tt>closedir()</tt>
family of functions for processing directory streams.
<tt>(open-directory-stream dir)</tt> creates a stream of files in the
directory <tt>dir</tt>. <tt>(read-directory-stream directory-stream)</tt>
returns the next file in the stream or <tt>#f</tt>if no such file exists.
Finally, <tt>(close-directory-stream directory-stream)</tt> closes the
stream.</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_354"></a></p>
<div align="left"><tt>(glob <i><i>pat</i><sub>1</sub> <tt>...</tt></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Glob each pattern against the filesystem and return the sorted list. 
Duplicates are not removed. Patterns matching nothing are <i>not</i> included 
literally, as they are in the shell.
Shell <code class="verbatim">{a,b,c}</code> patterns are expanded. Backslash quotes 
characters, turning off the special meaning of
<code class="verbatim">{</code>, <code class="verbatim">}</code>, <tt>*</tt>, <code class="verbatim">[</code>, <code class="verbatim">]</code>, and <code class="verbatim">?</code>. <p>
Note that the rules of backslash for Scheme strings and glob patterns
work together to require four backslashes in a row to specify a
single literal backslash. Fortunately, it is very rare that a backslash
occurs in a P<small>OSIX</small> file name.</p>
<p>
A glob subpattern will not match against dot files unless the first
character of the subpattern is a literal "<tt>.</tt>". 
Further, a dot subpattern will not match the files <tt>.</tt> or <tt>..</tt> 
unless it is a constant pattern, as in <tt>(glob "../*/*.c")</tt>.
So a directory's dot files can be reliably generated
with the simple glob pattern <tt>".*"</tt>.</p>
<p>
Some examples:
</p>
<blockquote>
<pre class="verbatim">(glob "*.c" "*.h")
    ;; All the C and #include files in my directory.

(glob "*.c" "*/*.c")
    ;; All the C files in this directory and 
    ;; its immediate subdirectories.

(glob "lexer/*.c" "parser/*.c")
(glob "{lexer,parser}/*.c")
    ;; All the C files in the lexer and parser dirs.

(glob "\\{lexer,parser\\}/*.c")
    ;; All the C files in the strange 
    ;; directory "{lexer,parser}".

(glob "*\\*")
    ;; All the files ending in "*", e.g.
    ;; ("foo*" "bar*")         

(glob "*lexer*")
    ("mylexer.c" "lexer1.notes") 
    ;; All files containing the string "lexer".

(glob "lexer")
    ;; Either ("lexer") or ().</pre><p>
</p>
</blockquote>
If the first character of the pattern (after expanding braces) is a slash,
the search begins at root; otherwise, the search begins in the current
working directory.<p>
If the last character of the pattern (after expanding braces) is a slash,
then the result matches must be directories, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(glob&nbsp;"/usr/man/man?/")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("/usr/man/man1/"&nbsp;"/usr/man/man2/"&nbsp;<tt>...</tt>)</tt></blockquote><p>
Globbing can sometimes be useful when we need a list of a directory's files
where each element in the list includes the pathname for the file.
Compare:
</p>
<blockquote><tt><br>
(directory-files&nbsp;"../include")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;("cig.h"&nbsp;"decls.h"&nbsp;<tt>...</tt>)<br>
<br>
(glob&nbsp;"../include/*")&nbsp;==&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;("../include/cig.h"&nbsp;"../include/decls.h"&nbsp;<tt>...</tt>)</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_356"></a></p>
<div align="left"><tt>(glob-quote <i>str</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns a constant glob pattern that exactly matches <i>str</i>.
All wild-card characters in <i>str</i> are quoted with a backslash.
<blockquote><tt><br>
(glob-quote&nbsp;"Any&nbsp;*.c&nbsp;files?")<br>
&nbsp;&nbsp;&nbsp;&nbsp;==&gt;&nbsp;"Any&nbsp;\*.c&nbsp;files\?"</tt></blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_idx_364"></a><div align="left"><tt>temp-file-prefix</tt> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string parameter</i>&nbsp;</div>
<p></p>
<blockquote>
A SRFI 39 or R7RS parameter that returns a string.  Its initial value is
the value of the environment variable <tt>TMPDIR</tt> concatenated with <tt>"/<i>pid</i>"</tt>
if <tt>TMPDIR</tt> is set and to
<tt>"/var/tmp/<i>pid</i>"</tt> otherwise, where <i>pid</i> is the id of the current process.
</blockquote>
<a name="node_idx_360"></a><div align="left"><tt>(create-temp-file <i>[prefix]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><tt>Create-temp-file</tt> creates a new temporary file and return its name.
The optional argument specifies the filename prefix to use, and defaults
to the result of invoking <tt>temp-file-prefix</tt>.
The procedure generates a sequence of filenames that have <i>prefix</i> as
a common prefix, looking for a filename that doesn't already exist in the
file system. When it finds one, it creates it, with permission <tt>#o600</tt>
and returns the filename. (The file permission can be changed to a more
permissive permission with <tt>set-file-mode</tt> after being created).<p>
This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very
likely to be unused. It returns a filename that definitely did not exist
at the moment <tt>create-temp-file</tt> created it.</p>
<p>
It is not necessary for the process' pid to be a part of the filename
for the uniqueness guarantees to hold. The pid component of the default
prefix simply serves to scatter the name searches into sparse regions, so
that collisions are less likely to occur. This speeds things up, but does
not affect correctness.</p>
<p>
Security note: doing I/O to files created this way in <tt>/var/tmp/</tt> is
not necessarily secure. General users have write access to <tt>/var/tmp/</tt>,
so even if an attacker cannot access the new temp file, he can delete it
and replace it with one of his own. A subsequent open of this filename
will then give you his file, to which he has access rights. There are
several ways to defeat this attack,
</p>
<ol>
<li><p>Use <tt>temp-file-iterate</tt>, below, to return the file descriptor
allocated when the file is opened. This will work if the file
only needs to be opened once.
</p>
</li><li><p>If the file needs to be opened twice or more, create it in a 
protected directory, <em>e.g.</em>, <code class="verbatim">$HOME</code>.</p>
</li><li><p>Ensure that <tt>/var/tmp</tt> has its sticky bit set. This
requires system administrator privileges.
</p>
</li></ol>
</blockquote><p>
<a name="node_idx_362"></a></p>
<div align="left"><tt>(temp-file-iterate <i>maker [prefix]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>object</i><sup>+</sup></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
                     
<blockquote>
This procedure can be used to perform certain atomic transactions on
the file system involving filenames. Some examples:
<ul>
<li><p>Linking a file to a fresh backup temp name.
</p>
</li><li><p>Creating and opening an unused, secure temp file.
</p>
</li><li><p>Creating an unused temporary directory.
</p>
</li></ul><p></p>
<p>
This procedure uses <i>prefix</i> to generate a series of trial
file names.  <i>Prefix</i> is a string, and
defaults to the value of invoking <tt>temp-file-prefix</tt>.
File names are generated by
concatenating <i>prefix</i>
with a varying string.<p>
<i>Maker</i> is a procedure which is serially called on each file name
generated.  It must return at least one value; it may return multiple
values. If the first return value is <tt>#f</tt> or if <i>maker</i> raises the
<tt>errno/exist</tt> errno exception, <tt>temp-file-iterate</tt> will loop,
generating a new file name and calling <i>maker</i> again. If the first
return value is true, the loop is terminated, returning whatever value(s)
<i>maker</i> returned.</p>
<p>
After a number of unsuccessful trials, <tt>temp-file-iterate</tt> may give up
and signal an error.</p>
<p>
Thus, if we ignore its optional <i>prefix</i> argument, 
<tt>create-temp-file</tt> could be defined as:
</p>
<blockquote><tt><br>
(define&nbsp;(create-temp-file)<br>
&nbsp;&nbsp;(let&nbsp;((flags&nbsp;(bitwise-ior&nbsp;open/create&nbsp;open/exclusive)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(temp-file-iterate&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(f)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(close&nbsp;(open-output-file&nbsp;f&nbsp;flags&nbsp;#o600))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f))))</tt></blockquote><p>
To rename a file to a temporary name:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(create-hard-link&nbsp;old-file&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".#temp.~a")&nbsp;;&nbsp;Keep&nbsp;link&nbsp;in&nbsp;cwd.<br>
(delete-file&nbsp;old-file)</tt></blockquote>
Recall that this SRFI reports procedure failure by raising an error
exception, not by returning an error code. This is critical to
to this example &mdash; the programmer can assume that if the 
<tt>temp-file-iterate</tt> call returns, it returns successully.
So the following <tt>delete-file</tt> call can be reliably invoked,
safe in the knowledge that the backup link has definitely been established.<p>
To create a unique temporary directory:
</p>
<blockquote><tt><br>
(temp-file-iterate&nbsp;(lambda&nbsp;(dir)&nbsp;(create-directory&nbsp;dir)&nbsp;dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/var/tmp/tempdir.~a")</tt></blockquote>
Similar operations can be used to generate unique symlinks and fifos,
or to return values other than the new filename (<em>e.g.</em>, an open file
descriptor or port).<p>
For increased security, a user may wish to
change the template to use a directory not allowing world write
access (<em>e.g.</em>, his home directory).
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_366"></a></p>
<div align="left"><tt>(real-path <i>path</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns an absolute pathname
derived from <i>pathname</i> that names the same file
and whose resolution does not involve <tt>.</tt>, <tt>..</tt>, or symbolic links.
</blockquote>
<a name="node_sec_3.4"></a>
<h2><a href="#node_toc_node_sec_3.4">3.4&nbsp;&nbsp;Processes</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_368"></a></p>
<div align="left"><tt>(exec <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_370"></a><div align="left"><tt>(exec-path <i>prog <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_372"></a><div align="left"><tt>(exec/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_374"></a><div align="left"><tt>(exec-path/env <i>prog env <i>arg</i><sub>1</sub> <tt>...</tt><i>arg</i><sub><em>n</em></sub></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>never returns</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>
The <tt><tt>...</tt>/env</tt> variants take an environment specified as a 
string&mdash;&gt;string alist.
An environment of <tt>#t</tt> is taken to mean the current process' environment 
(i.e., the value of the external char <tt>**environ</tt>).</p>
<p>
The path-searching variants search the directories in the list 
<tt>exec-path-list</tt> for the program.
A path-search is not performed if the program name contains
a slash character &mdash; it is used directly. So a program with a name like
<tt>"bin/prog"</tt> always executes the program <tt>bin/prog</tt> in the current working
directory. See <code class="verbatim">$path</code> and <code class="verbatim">exec-path-list</code>, below.</p>
<p>
Note that there is no analog to the C function <tt>execv()</tt>.
To get the effect just do
</p>
<blockquote><tt>(apply exec prog arglist)</tt></blockquote><p>
All of these procedures may flush buffered output.
<p>
Note that the C <tt>exec()</tt> procedure allows the zeroth element of the
argument vector to be different from the file being executed, <em>e.g.</em></p>
<blockquote>
<pre class="verbatim">char *argv[] = {"-", "-f", 0};
exec("/bin/csh", argv, envp);</pre><p>
</p>
</blockquote>
The SRFI <tt>exec</tt>, <tt>exec-path</tt>, <tt>exec/env</tt>, and <tt>exec-path/env</tt>
procedures do not give this functionality &mdash; element 0 of the arg vector is
always identical to the <tt>prog</tt> argument. 
These procedures never return under any circumstances.
As with any other system call, if there is an error, they raise
an exception.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_idx_386"></a><div align="left"><tt>(suspend<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Suspend the current process with a SIGSTOP signal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_388"></a></p>
<div align="left"><tt>(fork <i>[thunk or <tt>#f</tt>]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>


<blockquote>
<tt>fork</tt> with no arguments or <tt>#f</tt> instead of a thunk is like
<tt>fork()</tt>.
In the parent process, it returns the child's <em>process object</em>
(see below for more information on process objects).  In the child
process, it returns <tt>#f</tt>.<p>
<tt>fork</tt> with an argument only returns in the parent process, returning
the child's process object.
The child process calls <i>thunk</i> and then exits.</p>
<p>
<tt>fork</tt> may or may not flush buffered output before forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_392"></a></p>
<div align="left"><tt>(fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_394"></a><div align="left"><tt>(%fork/pipe <i>[thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork</tt> and <tt>%fork</tt>, but the parent and child communicate via a
pipe connecting the parent's stdin to the child's stdout. These procedures
side-effect the parent by changing his stdin.<p>
In effect, <tt>fork/pipe</tt> splices a process into the data stream
immediately upstream of the current process.
This is the basic function for creating pipelines.
Long pipelines are built by performing a sequence of <tt>fork/pipe</tt> calls.
For example, to create a background two-process pipe <tt>a | b</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)&nbsp;(b)))</tt></blockquote>
which returns the process object for <tt>b</tt>'s process.<p>
To create a background three-process pipe <tt>a | b | c</tt>, we write:
</p>
<blockquote><tt><br>
(fork&nbsp;(lambda&nbsp;()&nbsp;(fork/pipe&nbsp;a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fork/pipe&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c)))</tt></blockquote>
which returns the process object for <tt>c</tt>'s process.<p>
Note that these procedures affect file descriptors, not ports.
That is, the pipe is allocated connecting the child's file descriptor
1 to the parent's file descriptor 0.
<em>Any previous Scheme port built over these affected file descriptors
is shifted to a new, unused file descriptor with <tt>dup</tt> before
allocating the I/O pipe.</em>
This means, for example, that the ports bound to <tt>(current-input-port)</tt>
and <tt>(current-output-port)</tt> in either process are not affected &mdash; they 
still refer to the same I/O sources and sinks as before.
Remember the simple SRFI rule: Scheme ports are bound to I/O sources
and sinks, <em>not</em> particular file descriptors.</p>
<p>
If the child process wishes to rebind the current output port
to the pipe on file descriptor 1, it can do this using 
<tt>with-current-output-port</tt> or a related form.
Similarly, if the parent wishes to change the current input port
to the pipe on file descriptor 0, it can do this using
<tt>set-current-input-port!</tt> or a related form.
Here is an example showing how to set up the I/O ports on both sides
of the pipe:
</p>
<blockquote><tt><br>
(fork/pipe&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-current-output-port&nbsp;(fdesfdes&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"Hello,&nbsp;world.\n"))))<br>
<br>
(set-current-input-port!&nbsp;(fdes-&gt;inport&nbsp;0))<br>
(read-line)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;Read&nbsp;the&nbsp;string&nbsp;output&nbsp;by&nbsp;the&nbsp;child.</tt></blockquote>
None of this is necessary when the I/O is performed by an exec'd
program in the child or parent process, only when the pipe will
be referenced by Scheme code through one of the default current I/O
ports.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_396"></a></p>
<div align="left"><tt>(fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_398"></a><div align="left"><tt>(%fork/pipe+ <i>conns [thunk] [continue-threads?]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>proc or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Like <tt>fork/pipe</tt>, but the pipe connections between the child and parent
are specified by the connection list <i>conns</i>. 
See the 
<blockquote><tt>(|+ <i>conns</i> <i>pf</i><sub>1</sub> <tt>...</tt> <i>pf</i><sub><em>n</em></sub>)</tt></blockquote>process form for a description of connection lists.
</blockquote><p>
</p>
<a name="node_sec_3.4.1"></a>
<h3><a href="#node_toc_node_sec_3.4.1">3.4.1&nbsp;&nbsp;Process objects</a></h3>
<p>
This SRFI uses <em>process objects</em> to represent P<small>OSIX</small> processes.
They are created by the <tt>fork</tt> procedure, and 
are opaque objects wrapping the pid of the process, the integer id
assigned by the kernel to the process.
<div align="left"><tt>(proc? <i>obj</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if <i>obj</i> is a process object and <tt>#f</tt> otherwise.
</blockquote>
<div align="left"><tt>(proc:pid <i>proc</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if <i>obj</i> is a process object and <tt>#f</tt> otherwise.
</blockquote>
<a name="node_sec_3.4.2"></a>
<h3><a href="#node_toc_node_sec_3.4.2">3.4.2&nbsp;&nbsp;Process waiting</a></h3>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_412"></a></p>
<div align="left"><tt>(wait <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>status</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure waits until a child process exits, and returns its
exit code. The <i>proc/pid</i> argument is either a process object
(section <a href="#node_sec_3.4.1">3.4.1</a>) or an exact integer process id.
<tt>Wait</tt> returns the child's exit status code (or suspension code,
if the <tt>wait/stopped-children</tt> option is used, see below).
Status values can be queried with the procedures in section 
<a href="#node_sec_3.4.3">3.4.3</a>.<p>
The <i>flags</i> argument is an exact integer whose bits specify
additional options. It is composed by adding together the following
flags:
</p>
<div align="center"><table><tbody><tr><td>

<table border="1"><tbody><tr><td valign="top">Flag                    </td><td valign="top">Meaning                           </td></tr>
<tr><td valign="top"><tt>wait/poll</tt>          </td><td valign="top">Return <tt>#f</tt> immediately if
child still active.               </td></tr>
<tr><td valign="top"><tt>wait/stopped-children</tt>      </td><td valign="top">Wait for suspend as well as exit. </td></tr>
<tr><td valign="top"></td></tr></tbody></table>
</td></tr></tbody></table></div>

</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<a name="node_idx_416"></a><div align="left"><tt>(wait-process-group <i>proc/pid [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>[proc status]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure waits for any child whose process group is <i>proc/pid</i>
(either a process object or a pid).
The <i>flags</i> argument is as for <tt>wait</tt>.
</blockquote><p>
</p>
<a name="node_sec_3.4.3"></a>
<h3><a href="#node_toc_node_sec_3.4.3">3.4.3&nbsp;&nbsp;Analysing process status codes</a></h3>
<p>
When a child process dies (or is suspended), its parent can call the <tt>wait</tt>
procedure to recover the exit (or suspension) status of the child.
The exit status is a small integer that encodes information
describing how the child terminated.
The bit-level format of the exit status is not defined by P<small>OSIX</small>;
you must use the following three functions to decode one.
However, if a child terminates normally with exit code 0,
P<small>OSIX</small> does require <tt>wait</tt> to return an exit status that is exactly
zero.
So <tt>(zero? <i>status</i>)</tt> is a correct way to test for non-error, 
normal termination, <em>e.g.</em>,
</p>
<blockquote><tt><br>
(if&nbsp;(zero?&nbsp;(run&nbsp;(rcp&nbsp;SRFI.tar.gz&nbsp;lambda.csd.hku.hk:)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(delete-file&nbsp;"SRFI.tar.gz"))</tt></blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_418"></a></p>
<div align="left"><tt>(status:exit-val <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_420"></a><div align="left"><tt>(status:stop-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_422"></a><div align="left"><tt>(status:term-sig <i>status</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i> or <tt>#f</tt></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
For a given status value produced by calling <tt>wait</tt>,
exactly one of these routines will return a true value.<p>
If the child process exited normally, <tt>status:exit-val</tt> returns the
exit code for the child process (i.e., the value the child passed to <tt>exit</tt> 
or returned from <tt>main</tt>). Otherwise, this function returns false.</p>
<p>
If the child process was suspended by a signal, <tt>status:stop-sig</tt>
returns the signal that suspended the child.
Otherwise, this function returns false.</p>
<p>
If the child process terminated abnormally, <tt>status:term-sig</tt>
returns the signal that terminated the child.
Otherwise, this function returns false.
</p>
</blockquote><p>
</p>
<p>
</p>
<p>
</p>
<a name="node_sec_3.5"></a>
<h2><a href="#node_toc_node_sec_3.5">3.5&nbsp;&nbsp;Process state</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_424"></a></p>
<div align="left"><tt>(umask<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_426"></a><div align="left"><tt>(set-umask <i>perms</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The process' current umask is retrieved with <tt>umask</tt>, and set with
<tt>(set-umask <i>perms</i>)</tt>. 
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_432"></a></p>
<div align="left"><tt>(chdir <i>[fname]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_434"></a><div align="left"><tt>(cwd<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These forms manipulate the current working directory.
The cwd can be changed with <tt>chdir</tt>.
If <tt>chdir</tt> is called with no arguments, it changes the cwd to
the user's home directory.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_440"></a></p>
<div align="left"><tt>(pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_442"></a><div align="left"><tt>(parent-pid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_444"></a><div align="left"><tt>(process-group<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_446"></a><div align="left"><tt>(set-process-group <i>[proc/pid] pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>    
<tt>(pid)</tt> and <tt>(parent-pid)</tt> retrieve the process id for the 
current process and its parent.
<tt>(process-group)</tt> returns the process group of the current process.
A process' process-group can be set with <tt>set-process-group</tt>; 
the value <i>proc/pid</i> specifies the affected process. It may be either
a process object or an exact integer process id, and defaults to the current
process.
</blockquote><p>
</p>
<p></p>
<p></p>
<a name="node_idx_452"></a><div align="left"><tt>(nice <i>[proc/pid delta]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
This procedure sets the niceness value of a process.
The higher the niceness, the lower the effective priority.
</blockquote><p>
<a name="node_idx_454"></a></p>
<div align="left"><tt>(user-login-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_456"></a><div align="left"><tt>(user-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_458"></a><div align="left"><tt>(user-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_460"></a><div align="left"><tt>(user-supplementary-gids<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_462"></a><div align="left"><tt>(set-uid <i>uid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_464"></a><div align="left"><tt>(set-gid <i>gid</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These routines get and set the effective and real user and group ids.    
The <tt>set-uid</tt> and <tt>set-gid</tt> routines correspond to the P<small>OSIX</small>
<tt>setgid()</tt> procedures.
</blockquote><p>
<a name="node_idx_466"></a></p>
<div align="left"><tt>(user-effective-uid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_468"></a><div align="left"><tt>(set-user-effective-uid <i><i>exact integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_474"></a><div align="left"><tt>(user-effective-gid<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_476"></a><div align="left"><tt>(set-user-effective-gid <i><i>exact integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<p>
</p>
<blockquote>
These forms manipulate the effective user/group IDs. Possible values
for setting this resource are either the real user/group ID or the
saved set-user/group-ID. 
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_482"></a></p>
<div align="left"><tt>(process-times<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>[<i>exact integer</i> <i>exact integer</i> <i>exact integer</i> <i>exact integer</i>]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns four values:
<blockquote>
<div align="left"><table><tbody><tr><td>

user CPU time in clock-ticks            <br>
system CPU time in clock-ticks          <br>
user CPU time of all descendant processes        <br>
system CPU time of all descendant processes
</td></tr></tbody></table></div>

</blockquote>
Note that CPU time clock resolution is not the same as 
the real-time clock resolution providesd by <tt>time+ticks</tt>.
That's P<small>OSIX</small>.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_484"></a></p>
<div align="left"><tt>(cpu-ticks/sec<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns the resolution of the CPU timer in clock ticks per second.
This can be used to convert the times reported by <tt>process-times</tt>
to seconds.
</blockquote><p>
</p>
<a name="node_sec_3.6"></a>
<h2><a href="#node_toc_node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</a></h2>
<p>These procedures are used to access the user and group databases
(<em>e.g.</em>, the ones traditionally stored in <tt>/etc/passwd</tt> and <tt>/etc/group</tt>.)</p>
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_486"></a></p>
<div align="left"><tt>(user-info <i>uid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>user-info</tt> record giving the recorded information for a
particular user:
<a name="node_idx_488"></a>
<a name="node_idx_490"></a>
<a name="node_idx_492"></a>
<a name="node_idx_494"></a>
<a name="node_idx_496"></a>
<a name="node_idx_498"></a>
<blockquote><tt><br>
(define-record&nbsp;user-info<br>
&nbsp;&nbsp;name&nbsp;uid&nbsp;gid&nbsp;home-dir&nbsp;shell)</tt></blockquote>
The <i>uid/name</i> argument is either an exact integer uid or a string user-name.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_500"></a></p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_504"></a></p>
<div align="left"><tt>(group-info <i>gid/name</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a <tt>group-info</tt> record giving the recorded information for a
particular group:
<a name="node_idx_506"></a>
<a name="node_idx_508"></a>
<a name="node_idx_510"></a>
<a name="node_idx_512"></a>
<blockquote><tt><br>
(define-record&nbsp;group-info<br>
&nbsp;&nbsp;name&nbsp;gid&nbsp;members)</tt></blockquote>
The <i>gid/name</i> argument is either an exact integer gid or a string group-name.
</blockquote><p>
</p>
<a name="node_sec_3.7"></a>
<h2><a href="#node_toc_node_sec_3.7">3.7&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<a name="node_sec_3.8"></a>
<h2><a href="#node_toc_node_sec_3.8">3.8&nbsp;&nbsp;System parameters</a></h2>
<p></p>
<p></p>
<p></p>
<p><a name="node_idx_524"></a></p>
<div align="left"><tt>(system-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Returns the name of the host on which we are executing.
This may be a local name, such as "solar," as opposed to a
fully-qualified domain name such as "solar.csie.ntu.edu.tw."
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_526"></a></p>
<div align="left"><tt>(uname<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>uname-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Returns a uname record.
</blockquote>

<div align="left"><tt>(uname? <i>obj</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <tt>#t</tt> if <i>obj</i> is a uname record and <tt>#f</tt> otherwise.
</blockquote>

<div align="left"><tt>(uname:os-name <i>uname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the OS name stored in <i>uname</i>.</blockquote>
<div align="left"><tt>(uname:node-name <i>uname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the node name stored in <i>uname</i>.</blockquote>
<div align="left"><tt>(uname:release-name <i>uname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the OS release name stored in <i>uname</i>.</blockquote>
<div align="left"><tt>(uname:version <i>uname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the OS version stored in <i>uname</i>.</blockquote>
<div align="left"><tt>(uname:machine <i>uname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the machine name stored in <i>uname</i>.</blockquote>
<p>Each of the fields contains a string.</p>
<p>
Be aware that P<small>OSIX</small> limits the length of all entries to 32 characters,
and that the node name does not necessarily correspond to the
fully-qualified domain name.
</p>
</blockquote><p>
</p>
<a name="node_sec_3.9"></a>
<h2><a href="#node_toc_node_sec_3.9">3.9&nbsp;&nbsp;Signal system</a></h2>
<p>Signal numbers are bound to the variables <tt>signal/hup</tt>, <tt>signal/int</tt>, etc.
See <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">
the P<small>OSIX</small> specification of <tt>signal.h</tt></a> for the complete list.
<p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_528"></a></p>
<div align="left"><tt>(signal-process <i>proc sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<a name="node_idx_530"></a><div align="left"><tt>(signal-process-group <i>prgrp sig</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
These two procedures send signals to a specific process, and all the processes
in a specific process group, respectively.
The <i>proc</i> and <i>prgrp</i> arguments are either processes 
or integer process ids.
</blockquote><p>
</p>
<p></p>
<p></p>
<p>
<a name="node_idx_664"></a><div align="left"><tt>(set-signal-handler <i>signal handler</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>old-handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Assigns a handler for a given signal, 
and returns the signal's old handler.
The <i>handler</i> argument is <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an exact integer argument representing the signal number ;
the return value follows the same conventions.
It is an error to provide a procedure for a synchronous signal.
</blockquote>
</p>
<a name="node_idx_666"></a><div align="left"><tt>(signal-handler <i>signal</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>handler</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
Return the handler for a given interrupt.
A handler is either <tt>#f</tt> (ignore), <tt>#t</tt> (default), or a
procedure taking an exact integer argument.
</blockquote><p>
<p><a name="node_idx_668"></a></p>
<div align="left"><tt>(ignore-signal <i><i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_670"></a><div align="left"><tt>(handle-signal-default <i><i>integer</i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The procedure <tt>ignore-signal</tt> tells the process to ignore the
given signal. The procedure <tt>handle-signal-default</tt> resets the
signal handler to the default handler.<p>
</blockquote><p>
</p>
<p>
</p>
<a name="node_sec_3.10"></a>
<h2><a href="#node_toc_node_sec_3.10">3.10&nbsp;&nbsp;Time</a></h2>
<p><a name="node_idx_680"></a></p>
<div align=left><tt>(time+ticks<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i>[secs ticks]</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_682"></a><div align=left><tt>(ticks/sec<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;---&gt; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>real</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
The current time, with sub-second resolution.
The time is returned as elapsed seconds since the Unix epoch excluding leap seconds, plus
a number of sub-second "ticks."
The length of a tick may vary, but a value of 1 nanosecond is recommended;
it can be determined from <tt>(ticks/sec)</tt>.
The system clock is not required to report time at the full resolution
given by <tt>(ticks/sec)</tt>. 
If the OS does not support sub-second resolution, the <i>ticks</i> value
is always 0, and <tt>(ticks/sec)</tt> returns 1.</p>
<p>
</p>
System clock resolution is represented as ticks per second
instead of seconds per tick to increase the odds that the value could
be represented as an exact integer, increasing efficiency and
making it easier for Scheme implementations that don't have
sophisticated numeric support to deal with the quantity.<p>
You can convert seconds and ticks to seconds with the expression
</p>
<blockquote><tt>(+ <i>secs</i> (/ <i>ticks</i> (ticks/sec)))</tt></blockquote>Given that, why not have the fine-grain time procedure just
return a non-integer real for time? Following Common Lisp, I chose to
allow the system clock to report sub-second time in its own units to
lower the overhead of determining the time.  This would be important
for a system that wanted to precisely time the duration of some
event. Time stamps could be collected with little overhead, deferring
the overhead of precisely calculating with them until after collection.<p>
</p>
</blockquote>
</blockquote><p>
</p>
<p></p>
<p></p>
<h2><a href="#node_toc_node_sec_3.11">3.11&nbsp;&nbsp;[Intentionally omitted]</a></h2>
<a name="node_sec_3.12"></a>
<h2><a href="#node_toc_node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</a></h2>
<p></p>
<p>
</p>
<p>
P<small>OSIX</small> provides a complete set of routines for manipulating terminal
devices &mdash; putting them in "raw" mode, changing and querying their
special characters, modifying their I/O speeds, and so forth.
However, now that terminal emulators have almost completely displaced
terminals, very little of this is useful except for directly
controlling serial-line hardware, which itself is increasingly rare.
Therefore, this SRFI provides only the functions that are still
in common use: the ability to turn echoing on and off, the
ability to suppress the recognition of interrupt, quit, and
suspend characters; and the ability to put a terminal into
raw mode, in which no characters are specially recognized.
</p>

<p><a name="node_idx_728"></a></p>
<div align="left"><tt>(tty? <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return true if the argument is a tty.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_730"></a></p>
<div align="left"><tt>(tty-file-name <i>fd/port</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
Return the file-name of the tty.
</blockquote><p>
</p>
<p>The following procedures use <tt>dynamic-wind</tt> magic when executing
their <tt>thunk</tt> arguments; if the thunk's dynamic extent is escaped,
the action of the procedure is undone, but if the thunk's dynamic extent
is re-entered, the action of the procedure is re-enabled.</p>
<p><a name="node_idx_730a"></a></p>
<div align="left"><tt>(with-raw-mode <i>fd/port min time thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
The tty is set to raw mode during the dynamic execution of <tt>thunk</tt>
and then is restored to canonical ("cooked") mode.
</blockquote><p>
</p>
<p><a name="node_idx_730b"></a></p>
<div align="left"><tt>(without-echo <i>fd/port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
Echoing of input is disabled on the tty during the execution of <tt>thunk</tt>
and then is re-enabled.
</blockquote><p>
</p>
<p><a name="node_idx_730c"></a></p>
<div align="left"><tt>(without-interrupt-chars <i>fd/port thunk</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
The argument <i>fd/port</i> must be a file descriptor or port open on a tty.
The detection of interrupt (^C), quit (^\), and suspend (^Z) characters
on the tty is disabled during the execution of <tt>thunk</tt> and then is re-enabled.
</blockquote><p>
</p>
<p><a name="node_idx_786"></a></p>
<div align="left"><tt>(open-control-tty <i>tty-name [flags]</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure opens terminal device <i>tty-name</i> as the process'
control terminal 
(see the <tt>termios</tt> man page for more information on control terminals).
The <i>tty-name</i> argument is a file-name such as <tt>/dev/ttya</tt>.
The <i>flags</i> argument is a value suitable as the second argument
to the <tt>open-file</tt> call; it defaults to <tt>open/read+write</tt>, causing
the terminal to be opened for both input and output.<p>
The port returned is an input port if the <i>flags</i> permit it, 
otherwise an output port. 
R5RS/Scheme 48/SRFI do not have input/output ports,
so it's one or the other. 
However, you can get both read and write ports open on a terminal
by opening it read/write, taking the result input port,
and duping it to an output port with <tt>dup-fdes</tt>.</p>
<p>
This procedure guarantees to make the opened terminal the
process' control terminal only if the process does not have
an assigned control terminal at the time of the call.
If the SRFI process already has a control terminal, the results are undefined.</p>
<p>
To arrange for the process to have no control terminal prior to calling
this procedure, use the <tt>become-session-leader</tt> procedure.</p>
<p>
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_788"></a></p>
<div align="left"><tt>(become-session-leader<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This is the C <tt>setsid()</tt> call.
P<small>OSIX</small> job-control has a three-level hierarchy:
session/process-group/process. 
Every session has an associated control terminal.
This procedure places the current process into a brand new session,
and disassociates the process from any previous control terminal.
You may subsequently use <tt>open-control-tty</tt> to open a new control
terminal.<p>
It is an error to call this procedure if the current process is already
a process-group leader.
One way to guarantee this is not the case is only to call this procedure
after forking.
</p>
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_790"></a></p>
<div align="left"><tt>(tty-process-group <i>fd/port/fname</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<a name="node_idx_792"></a><div align="left"><tt>(set-tty-process-group <i>fd/port/fname pgrp</i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This pair of procedures gets and sets the process group of a given
terminal.
</blockquote><p>
</p>
<p></p>
<p></p>
<p><a name="node_idx_794"></a></p>
<div align="left"><tt>(control-tty-file-name<i></i>)</tt> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return the file-name of the process' control tty.
On every version of P<small>OSIX</small> of which we are aware, this is just the string
<tt>"/dev/tty"</tt>.
However, this procedure uses the official P<small>OSIX</small> interface, so it is more
portable than simply using a constant string.
</blockquote><p>
</p>
</p>
<p>
</p>
<p></p>
<p></p>

<h1>Implementation</h1>

<a href="https://scsh.net/">Scsh version 0.6.7</a>
constitutes an implementation of this SRFI, with the following exceptions and deviations:

<ul>
<li>
It's likely that not all of the error and signal numbers supported
by P<small>OSIX</small> are available in Scsh.
</li>
<li>
Scsh's version of <tt>seek</tt> doesn't handle <i>offset</i> arguments
that are not immediate integers (i.e., representable in 30 bits).
It doesn't handle buffered ports, either.
</li>
<ltt>Scsh does not have the <tt>open/text</tt> and <tt>open/binary</tt> flags,
because it does not run on Windows.  They may be defined as 0.
</li>
<li>There is no <tt>close-fdes</tt> procedure; standard Scheme's <tt>close-port</tt>
suffices.
</li>
<li>
Scsh <tt>set-port-buffering</tt> doesn't support <tt>bufpol/line</tt>.
</li>
<li>
Scsh does not support parameters, so <tt>temp-file-prefix</tt> does not exist.
Instead, there is a fluid variable named <tt>*temp-file-template*</tt> whose
value is as defined in this SRFI with <tt>"~a"</tt> appended to it.
</li>
<li>
Scsh does not support the <tt>real-path</tt> procedure, but it would be trivial to add
it to the source by cloning <tt>read-symlink</tt> and making it invoke the P<small>OSIX</small>
<tt>realpath()</tt> function.
</li>
<li>
In Scsh <tt>set-signal-handler</tt>
and <tt>signal-handler</tt> are called
<code>set-interrupt-handler</code>
and <tt>interrupt-handler</tt> respectively.
They accept a Scheme 48 interrupt
value rather than a signal value.  Fortunately, the Scsh procedure
<code>signal-&gt;interrupt</code> can be used to convert its argument
from a signal value to an interrupt value.</i></p>
</li>
</ul>


<h1>Acknowledgements</h1>

Thanks to Olin Shivers, <i>sine qua non</i>, and all the Scheme implementors
who have followed his work.  Thanks also to all the participants in the
SRFI mailing list.

<h1>Copyright</h1>
Copyright &copy; Olin Shivers, John Cowan 2019.

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
