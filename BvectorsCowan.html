<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI FIXME: Bit and boolean vector library</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

  <body>

<H1>Title</H1>

Bit and boolean vector library

<H1>Author</H1>

John Cowan

<H1>Abstract</H1>

This SRFI describes a set of operations on 
a homogeneous vector type known as <i>bvectors</i>.  These can be viewed either
as bit vectors whose element values are 0 and 1, or as boolean
vectors whose element values are <code>#f</code> and <code>#t</code>.
Operations analogous to those provided on the other homogeneous
vector types described in
<a href="http://srfi.schemers.org/srfi-160/srfi-160.html">SRFI 160</a>
are provided,
along with operations analogous to the bitwise operations of
<a href="http://srfi.schemers.org/srfi-151/srfi-151.html">SRFI 151</a>.
In addition,
a compact string representation compatible with Common Lisp is specified,
which may be supported by the <code>read</code> and <code>write</code>
procedures and by the program parser so that programs can contain
references to literal bvectors.

<H1>Issues</H1>

<ul>
  <li>None at present.</li>

</ul>

<H1>Rationale</H1>

Bit vectors were excluded from the final draft of SRFI 160 because they
are the only type of homogeneous numeric vectors for which bitwise
operations make sense.
In addition, providing both disjoint bit vectors and boolean vectors
would multiply entities beyond necessity, so this SRFI combines them.

<H1>Specification</H1>

<p>Whenever a bvector element is passed either to one of the procedures
defined in this SRFI or to a procedure that is passed as an argument
to one of them, any of 0, 1, <code>#t</code>, or <code>#f</code>
may be provided.  When an element value is returned in the same
circumstances, the procedure is split into <code>/bit</code> and
<code>/bool</code> versions.</p>

<p>Bvectors are disjoint from all other Scheme types, except that if a
Scheme implementation supports u1vectors as an extension to SRFI 160
or any other kind of bit or boolean vectors,
they should be the same type as bvectors.</p>

<H2>Notation</H2>

    <p>
      In the section containing specifications of procedures, the
      following notation is used to specify parameters and return
      values:
    </p>
    <dl>
      <dt><i>(f arg<sub>1</sub> arg<sub>2</sub> ...) -> something</i></dt> <dd>
        A procedure <tt><i>f</i></tt> that takes the parameters
        <tt><i>arg<sub>1</sub> arg<sub>2</sub>
        ...</i></tt> and returns a value of the
        type <tt><i>something</i></tt>.
        If two values are returned, two types are specified.
        If <tt><i>something</i></tt>
        is <tt>unspecified</tt>, then <tt><i>f</i></tt> returns a single
        implementation-dependent value; this SRFI does not specify what it
        returns, and in order to write portable code, the return value
        should be ignored.
        <br />
        <br />
      </dd>

      <dt><i>vec</i></dt>
      <dd>
        A heterogeneous vector, i.e. it must
        satisfy the predicate <tt>vector?</tt>.
        <br />
        <br />
      </dd>

      <dt><i>bvec, bto, bfrom</i></dt>
      <dd>
        A bvector, i.e. it must
        satisfy the predicate <tt>bvector?</tt>.
        In <tt>bvector-copy!</tt> and <tt>reverse-bvector-copy!</tt>,
        <i>bto</i> is the destination and <i>bfrom</i> is the source.
        <br />
        <br />
      </dd>

      <dt><i>i, j, start, at</i></dt>
      <dd>
        An exact nonnegative integer less than the length of the bvector.
        In <i>bvector-copy!</i> and <i>reverse-bvector-copy!</i>,
        <i>at</i> refers to the destination and <i>start</i> to the source.
        <br />
        <br />
      </dd>

      <dt><i>end</i></dt>
      <dd>
        An exact nonnegative integer not less than <i>start</i>.
        This indicates the index directly before
        which traversal will stop &mdash; processing will occur until
        the index of the vector is one less than <tt><i>end</i></tt>.  It is the
        open right side of a range.
        <br />
        <br />
      </dd>

      <dt><i>f</i></dt>
      <dd>
        A procedure taking one or more
        arguments, which returns (except as noted otherwise) exactly one value.
        <br />
        <br />
      </dd>

      <dt><i>pred?</i></dt>
      <dd>
        A procedure taking one or more
        arguments that returns one value, which is treated as a
        boolean.
        <br />
        <br />
      </dd>

      <dt><i>=</i></dt>
      <dd>
        An equivalence procedure.
        <br />
        <br />
      </dd>

      <dt><i>
        obj, seed, knil
      </i></dt>
      <dd>
        Any Scheme object.
        <br />
        <br />
      </dd>

      <dt><i>
        fill, value
      </i></dt>
      <dd>
        Any of 0, 1, <code>#f</code>, or <code>#t</code>.
        <br />

        <br />
      </dd>

      <dt><i>[something]</i></dt>
      <dd>
        An optional argument; it needn't necessarily be applied.
        <tt><i>Something</i></tt> needn't necessarily be one thing; for
        example, this usage of it is perfectly valid:
        <br />
        <br />
        <code>
          &nbsp;&nbsp;&nbsp;[start [end]]
        </code>
        <br />
        <br />
        and is indeed used quite often.
        <br />
        <br />
      </dd>

      <dt><i>something ...</i></dt>
      <dd>
        Zero or more <tt><i>something</i></tt>s are
        allowed to be arguments.
        <br />
        <br />
      </dd>

      <dt><i>
        something<sub>1</sub> something<sub>2</sub>
        ...
      </i></dt>
      <dd>
        At least one <tt><i>something</i></tt> must be
        arguments.
        <br />
        <br />
      </dd>

    </dl>


<H2>Procedures</H2>

<H3>Constructors</H3>

<p><code>(make-bvector <i>size</i> [<i>fill</i>]) -> bvector </code></p>

<p>Returns a bvector whose length is <i>size</i>.  If <i>fill</i> is provided,
all the elements of the bvector are initialized to it.</p>

<p><code>(bvector <i>value ...</i>) -> bvector </code></p>

<p>Returns a bvector initialized with <i>values</i>.</p>

<p><code>(bvector-unfold <i>f length seed ...</i>) -> bvector</code></p>

<p>Create a bvector whose length is <i>length</i> and initialize it by calling
f, f(f), f(f(f))) ... on the <i>seed</i>.</p>

<p><code>(bvector-unfold-right <i>f length seed ...</i>) -> bvector</code></p>

<p>The same as <code>bvector-unfold</code>, but initializes the bvector from right to left.</p>

<p><code>(bvector-copy <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> bvector</code></p>

<p>Makes a copy of the portion of <i>bvec</i> from <i>start</i> to <i>end</i> and returns it.</p>

<p><code>(bvector-reverse-copy <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> bvector</code></p>

<p>The same as <code>bvector-copy</code>, but in reverse order.</p>

<p><code>(bvector-append <i>bvec ...</i>) -> bvector</code></p>

<p>Returns a bvector containing all the elements of the <i>bvecs</i> in order.</p>

<p><code> (bvector-concatenate <i>list-of-bvectors</i>) -> bvector</code></p>

<p>The same as <code>bvector-append</code>, but takes a list of bvectors rather than
multiple arguments.</p>

<p><code>(bvector-append-subvectors [<i>bvec start end] ...</i>) -> bvector</code></p>

<p>Concatenates the result of applying <code>bvector-copy</code> to each triplet of
<i>bvec, start, end</i> arguments, but may be implemented more efficiently.</p>

<H3>Predicates</H3>

<p><code>(bvector? <i>obj</i>) -> boolean</code></p>

<p>Returns <code>#t</code> if <i>obj</i> is a bvector, and <code>#f</code>
otherwise.</p>

<p><code>(bvector-empty? <i>bvec</i>) -> boolean</code></p>

Returns <code>#t</code> if <i>bvec</i> has a length of zero,
and <code>#f</code> otherwise.

<p><code>(bvector= <i>elt=? bvec ...</i>) -> boolean</code></p>

<p>Compares the <i>bvecs</i> for elementwise equality, using
<i>elt=?</i> to do the comparisons.</p>

<H3>Selectors</H3>

<p><code>(bvector-ref/bit <i>bvec i</i>) -> value</code></p>

<p>Returns the <i>i</i>th element of <i>bvec</i> as 0 or 1.</p>

<p><code>(bvector-ref/bool <i>bvec i</i>) -> value</code></p>

<p>Returns the <i>i</i>th element of <i>bvec</i> as <code>#f</code> or <code>#t</code>.</p>

<p><code>(bvector-length <i>bvec</i>) -> exact nonnegative integer</code></p>

<p>Returns the length of <i>bvec</i></p>

<H3>Iteration</H3>

<p><code>(bvector-take <i>bvec n</i>) -> bvector</code>]</p>

<p><code>(bvector-take-right <i>bvec n</i>) -> bvector</code></p>

<p>Returns a bvector containing the first/last <i>n</i>
elements of <i>bvec</i>.</p>

<p><code>(bvector-drop <i>bvec n</i>) -> bvector</code></p>

<p><code>(bvector-drop-right <i>bvec n</i>) -> bvector</code></p>

<p>Returns a bvector containing all except the first/last <i>n</i>
elements of <i>bvec</i>.</p>

<p><code>(bvector-segment <i>bvec n</i>) -> list</code></p>

<p>Returns a list of bvectors, each of which contains <i>n</i>
consecutive elements of <i>bvec</i>.
The last bvector may be shorter than <i>n</i>.</p>

<p><code>(bvector-fold <i>kons knil bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> object</code></p>

<p><code>(bvector-fold-right <i>kons knil bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> object</code></p>

<p>Folds <i>kons</i> over the elements of <i>bvec</i> 
in increasing/decreasing order using <i>knil</i>
as the initial value.</p>

<p>Note that <code>bvector-map</code> is not provided, because of the restricted
range of the possible arguments.  See <code>bvector-field-flip</code> for a
procedure that can invert chosen bits in the bvector.

<p><code>(bvector-for-each <i>f bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> unspecified</code></p>

<p>Iterate over the elements of <i>bvec</i> and apply <i>f</i>
to each, returning respectively a bvector of the results,
an undefined value with the results placed back in <i>bvec</i>,
and an undefined value with no change to <i>bvec</i>.</p>

<p><code>(bvector-count <i>pred? bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> exact nonnegative integer</code></p>

Call <i>pred?</i> on the nth argument of each <i>bvec</i> and
return the number of calls that return true.</p>

<p><code>(bvector-cumulate <i>f knil bvec</i>) -> bvector</code></p>

<p>Like <code>bvector-fold</code>, but returns an bvector of partial results
rather than just the final result.</p>

<H3>Searching</H3>

<p><code>(bvector-take-while <i>bvec pred?</i> -> index</code></p>

<p><code>(bvector-take-while-right <i>bvec pred?</i> -> index</code></p>

<p>Return the shortest prefix/suffix of <i>bvec</i> all of whose elements
satisfy <i>pred?</i>.

<p><code>(bvector-drop-while <i>bvec pred</i> -> index</code></p>

<p><code>(bvector-drop-while-right <i>bvec pred</i> -> index</code></p>

Drops the longest initial prefix/suffix of <i>bvec</i> such that all its
elements satisfy <i>pred</i>.</p>

<p><code>(bvector-index <i>pred? bvec</i>) -> exact nonnegative integer or #f</code></p>

<p><code>(bvector-index-right <i>pred? bvec</i>) -> exact nonnegative integer or #f</code></p>

<p>Return the index of the first/last element of <i>bvec</i> that
satisfies <i>pred?</i>.

<p><code>(bvector-skip <i>pred? bvec</i>) -> exact nonnegative integer or #f</code></p>

<p><code>(bvector-skip-right <i>pred? bvec</i>) -> exact nonnegative integer or #f</code></p>

<p>Returns the index of the first/last element of <i>bvec</i> that
does not satisfy <i>pred?</i>.

<p><code>(bvector-binary-search <i>bvec value =</i>) -> exact nonnegative integer or #f</code></p>

<p>Returns the index of any element of <i>bvec</i> that is the same as
<i>value</i> in the sense of the <i>=</i> argument using a binary search.
Returns <code>#f</code> if there is no such element.</p>

<p><code>(bvector-any <i>pred? bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> value or #f</code></p>

<p>Returns the first set of elements from the <i>bvecs</i> which
satisfy <i>pred?</i>, or <code>#f</code> if there is no such set.</p>

<p><code>(bvector-every <i>pred? bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> value or #f</code></p>

<p>If all sets of elements from the <i>bvecs</i> satisfy <i>pred?</i>,
return the last set.  If none do, return <code>#f</code>.</p>

<p><code>(bvector-partition <i>pred? bvec</i>) -> bvector and integer</code></p>

<p>Returns a bvector of the same type as <i>bvec</i>, but with all elements
satisfying <i>pred?</i> in the leftmost part of the vector and the other
elements in the remaining part.  The order of elements is otherwise
preserved.  Returns two values, the new bvector and the number of 
elements satisfying <i>pred?</i>.</p>

<H3>Mutators</H3>

<p><code>(bvector-set! <i>bvec i value</i>) -> unspecified</code></p>

<p>Sets the <i>i</i>th element of <i>bvec</i> to <i>value</i>.</p>

<p><code>(bvector-swap! <i>bvec i j</i>) -> unspecified</code></p>

<p>Interchanges the <i>i</i>th and <i>j</i>th elements of <i>bvec</i>.</p>

<p><code>(bvector-fill! <i>bvec fill</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Fills the portion of <i>bvec</i> from <i>start</i> to <i>end</i>
with the value <i>fill</i>.</p>

<p><code>(bvector-reverse! <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Reverses the portion of <i>bvec</i> from <i>start</i> to <i>end</i>.</p>

<p><code>(bvector-copy! <i>bto at bfrom</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Copies the portion of <i>bfrom</i> from <i>start</i> to <i>end</i>
onto <i>bto</i>, starting at index <i>bat</i>.

<p><code>(bvector-reverse-copy! <i>bto at bfrom</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>The same as <code>bvector-copy!</code>, but copies in reverse.</p>

<H3>Conversion</H3>

<p><code>(bvector->list <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code></p>

<p><code>(reverse-bvector->list <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code></p>

<p><code>(list->bvector <i>proper-list</i>) -> bvector</code></p>

<p><code>(reverse-list->bvector <i>proper-list</i>) -> bvector</code></p>

<p><code>(bvector->vector <i>bvec</i>) -> vector</code></p>

<p><code>(vector->bvector <i>vec</i>) -> bvector</code></p>


<p>Returns a list, bvector, or heterogeneous vector with the same
elements as the argument, in reverse order where specified.</p>

<p><code>(bvector->string <i>vec</i>) -> string</code></p>

Returns a string beginning with <code>#*</code> and followed by the bits of <i>vec</i>
represented as 0 and 1 characters.</p>

<p><code>(string->bvector <i>string</i>) -> bvector</code></p>

Parses a string in the format generated by <code>bvector->string</code>
and returns the corresponding bvector, or <code>#f</code> if the
string is not in this format.</p>

<p>
<tt>(bvector->integer </tt><em>bvector</em> [ <em>len</em> ]<tt>)</tt><br />
</p>
<p>
Returns a non-negative integer whose bits, starting with the least significant bit as bit 0,
correspond to the bit in <em>bvector</em>.
</p>
<p>
<tt>(integer->bvector </tt><em>integer</em><tt>)</tt><br />
</p>
<p>
Returns a bvector whose bits correspond to the bits of <em>integer</em>,
starting with the least significant bit as bit 0.  It is an error if
<em>integer</em> is negative.
</p>

<h3>Generators</h3>
<p>
<tt>(make-bvector-generator </tt><em>bvector</em><tt>)</tt>
</p>
<p>
Returns a <a href="http://srfi.schemers.org/srfi-121/srfi-121.html">SRFI 121</a>
generator that generates all the values of <em>bvector</em> in order.
Note that the generator is finite.
</p>
<H2>Bitwise operations</H2>

<p>
It is an error unless all <em>bvector</em>
arguments passed to the following procedures are of the same length.
</p>

<h3 id="Basicoperations">Basic operations</h3>
<p>
<tt>(bvector-not </tt><em>bvector</em><tt>)</tt>
</p>
<p>
Returns the bitwise complement of <em>bvector</em>; that is, all 1 bits are changed
to 0 bits and all 0 bits to 1 bits.
</p>
<p>
The following ten procedures correspond to the useful set
of non-trivial two-argument boolean functions. For each such function,
the corresponding bvector operator
maps that function across two or more bvectors in a bitwise fashion.
The core idea of this group of functions is this bitwise "lifting"
of the set of dyadic boolean functions to bvector parameters.
</p>
<p>
<tt>(bvector-and </tt><em>bvector1</em> <em>bvector2</em> <em>bvector</em> ...<tt>)</tt><br />
<tt>(bvector-ior </tt><em>bvector1</em> <em>bvector2</em> <em>bvector</em> ...<tt>)</tt><br />
<tt>(bvector-xor </tt><em>bvector1</em> <em>bvector2</em> <em>bvector</em> ...<tt>)</tt><br />
<tt>(bvector-eqv </tt><em>bvector1</em> <em>bvector2</em> <em>bvector</em> ...<tt>)</tt>
</p>
<p>
These operations are associative.
</p>
<p>
The <tt>bvector-eqv</tt> procedure produces the
complement of the <tt>bvector-xor</tt> procedure.  When applied to three
arguments, it does <em>not</em> produce a 1 bit
everywhere that a, b and c all agree. That is, it does <em>not</em> produce
</p>
<pre>
     (bvector-ior (bvector-and a b c)
                  (bvector-and (bvector-not a)
                               (bvector-not b)
                               (bvector-not c)))
</pre>
<p>
Rather, it produces <tt>(bvector-eqv a (bvector-eqv b c))</tt> or the equivalent
<tt>(bvector-eqv (bvector-eqv a b) c)</tt>.
</p>
<p>
<tt>(bvector-nand </tt><em>bvector1 bvector2</em><tt>)</tt><br />
<tt>(bvector-nor </tt><em>bvector1 bvector2</em><tt>)</tt><br />
<tt>(bvector-andc1 </tt><em>bvector1 bvector2</em><tt>)</tt><br />
<tt>(bvector-andc2 </tt><em>bvector1 bvector2</em><tt>)</tt><br />
<tt>(bvector-orc1 </tt><em>bvector1 bvector2</em><tt>)</tt><br />
<tt>(bvector-orc2 </tt><em>bvector1 bvector2</em><tt>)</tt>
</p>
<p>
These operations are not associative.
</p>
<h3 id="Quasiintegeroperations">Quasi-integer operations</h3>
<p>
<tt>(bvector-logical-shift </tt><em>bvector count</em><tt>)</tt>
</p>
<p>
Returns the logical left shift when <em>count</em>>0; right shift when <em>count</em>&lt;0.
Newly vacated bits are filled with 0.
</p>
<p>
<tt>(bvector-count </tt><em>bvector</em><tt>)</tt>
</p>
<p>
Returns the population count of 1's in <em>bvector</em>.
</p>
<p>
<tt>(bvector-integer-length </tt><em>bvector</em><tt>)</tt>
</p>
<p>
The number of bits needed to represent the numeric value of <em>bvector</em>, i.e.
with all zero bits at the end of the vector removed.
</p>
<p>
<tt>(bvector-if </tt><em>if-bvector then-bvector else-bvector</em><tt>)</tt>
</p>
<p>
Merge the bvectors <em>then-bvector</em> and <em>else-bvector</em>, with the bvector <em>if-bvector</em> determining
from which bvector to take each bit. That is, if the <em>k</em>th bit of <em>if-bvector</em>
is 1, then the <em>k</em>th bit of the result is the <em>k</em>th bit of <em>then-bvector</em>, otherwise
the <em>k</em>th bit of <em>else-bvector</em>.  
</p>


<p>
<tt>(bvector-first-set-bit </tt><em>bvector</em><tt>)</tt>
</p>
<p>
Return the index of the first (smallest index) 1 bit in <em>bvector</em>.
Return -1 if <em>bvector</em> contains no 1 bits.
</p>
<h3 id="Bitfieldoperations">Bit field operations</h3>
<p>
These functions operate on a contiguous field of bits (a "byte," in
Common Lisp parlance) in a given bvector. The <em>start</em> and <em>end</em>
arguments, which are not optional, are
non-negative exact integers specifying the field: it is the <em>end-start</em> bits
running from bit <em>start</em> to bit <em>end</em>-1.
</p>
<p>
<tt>(bvector-field </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
Returns the field from <em>bvector</em>, shifted
down to the least-significant position in the result.
</p>



<p>
<tt>(bvector-field-any? </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
Returns true if any of the field's bits are set in <em>bvector</em>, and false otherwise.
</p>



<p>
<tt>(bvector-field-every? </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
  Returns false if any of the field's bits are not set in <em>bvector</em>, and true otherwise.
</p>


<p>
<tt>(bvector-field-clear </tt><em>bvector start end</em><tt>)</tt><br />
<tt>(bvector-field-set </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
Returns <em>bvector</em> with the field's bits set to all 0s/1s.
</p>


<p>
<tt>(bvector-field-replace </tt><em>dest source start end</em><tt>)</tt>
</p>
<p>
Returns <em>dest</em> with the field replaced
by the least-significant <em>end-start</em> bits in <em>source</em>.
</p>



<p>
<tt>(bvector-field-replace-same </tt><em>dest source start end</em><tt>)</tt>
</p>
<p>
Returns <em>dest</em> with its field replaced
by the corresponding field in <em>source</em>.
</p>


<p>
<tt>(bvector-field-rotate </tt><em>bvector count start end</em><tt>)</tt>
</p>
<p>
Returns <em>bvector</em> with the field cyclically permuted
by <em>count</em> bits towards high-order.
</p>



<p>
<tt>(bvector-field-reverse </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
Returns <em>bvector</em> with the order of the bits in the field reversed.
</p>

<p>
<tt>(bvector-field-flip </tt><em>bvector start end</em><tt>)</tt>
</p>
<p>
Returns <em>bvector</em> with the bits in the field flipped:
that is, 0 becomes 1 and vice versa.  There is no SRFI 151 equivalent.
</p>




<h3>Bitwise mutators</h3>
<p>The operations
<code>bvector-not!</code>,
<code>bvector-and!</code>,
<code>bvector-ior!</code>,
<code>bvector-xor!</code>,
<code>bvector-eqv!</code>,
<code>bvector-nand!</code>,
<code>bvector-nor!</code>,
<code>bvector-andc1!</code>,
<code>bvector-andc2!</code>,
<code>bvector-orc1!</code>,
<code>bvector-orc2!</code>,
<code>bvector-field-clear!</code>,
<code>bvector-field-set!</code>,
<code>bvector-field-replace!</code>,
<code>bvector-field-replace-same!</code>,
<code>bvector-field-rotate!</code>,
<code>bvector-field-reverse!</code>,
and
<code>bvector-field-flip!</code>
have the same semantics as their counterparts without
<code>!</code>, except that instead of allocating a
result bvector, the first bvector argument is mutated
and an unspecified value returned.</p>

<H1>Implementation</H1>

<p>The sample implementation is (not yet) in the repository of this SRFI.
Bvectors are wrapped bytevectors; for simplicity and possibly for speed,
they use a whole byte to represent each bit as Java and C# do.
At a later date, a more
complex implementation that packs bits into bytes may be provided.


<H1>Copyright</H1>
Copyright &copy; John Cowan 2018.
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<hr>
<address>Editor: <a href="mailto:srfi minus editors at srfi dot schemers dot org">
  Arthur A. Gleckler</a></address>

  </body>
</html>
