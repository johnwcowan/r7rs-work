<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI FIXME: Boolean vector library</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

  <body>

<H1>Title</H1>

Boolean vector library

<H1>Author</H1>

John Cowan

<H1>Abstract</H1>

This SRFI describes a set of operations on 
homogeneous boolean vectors.
Operations analogous to those provided on the other homogeneous
vector types described in
<a href="http://srfi.schemers.org/srfi-160/srfi-160.html">SRFI 160</a>
are provided,
along with operations analogous to the bitwise operations of
<a href="http://srfi.schemers.org/srfi-151/srfi-151.html">SRFI 151</a>.
In addition,
a compact string representation compatible with Common Lisp is specified,
which may be supported by the <code>read</code> and <code>write</code>
procedures and by the program parser so that programs can contain
references to literal boolean vectors.

<H1>Issues</H1>

<ul>
  <li>None at present.</li>

</ul>

<H1>Rationale</H1>

Bit vectors were excluded from the final draft of SRFI 160 because they
are the only type of homogeneous numeric vectors for which bitwise
operations make sense.
In addition, providing both disjoint u1vectors and boolean vectors
would multiply entities beyond necessity, so this SRFI provides only
the latter on the assumption that booleans are more generally useful
than exact integers over such a small range.
It is trivial to shim boolean vectors to accept and return integers,
as well as to implement this SRFI on top of existing u1vectors.
Boolean vectors are known as <i>bvectors</i> for short.

<H1>Specification</H1>

<p>Bvectors are disjoint from all other Scheme types.</p>

<H2>Notation</H2>

    <p>
      In the section containing specifications of procedures, the
      following notation is used to specify parameters and return
      values:
    </p>
    <dl>
      <dt><i>(f arg<sub>1</sub> arg<sub>2</sub> ...) -> something</i></dt> <dd>
        A procedure <code><i>f</i></code> that takes the parameters
        <code><i>arg<sub>1</sub> arg<sub>2</sub>
        ...</i></code> and returns a value of the
        type <code><i>something</i></code>.
        If two values are returned, two types are specified.
        If <code><i>something</i></code>
        is <code>unspecified</code>, then <code><i>f</i></code> returns a single
        implementation-dependent value; this SRFI does not specify what it
        returns, and in order to write portable code, the return value
        should be ignored.
        <br />
        <br />
      </dd>

      <dt><i>vec</i></dt>
      <dd>
        A heterogeneous vector, i.e. it must
        satisfy the predicate <code>vector?</code>.
        <br />
        <br />
      </dd>

      <dt><i>bvec, to, from</i></dt>
      <dd>
        A bvector, i.e. it must
        satisfy the predicate <code>bvector?</code>.
        In <code>bvector-copy!</code> and <code>reverse-bvector-copy!</code>,
        <i>to</i> is the destination and <i>from</i> is the source.
        <br />
        <br />
      </dd>

      <dt><i>i, j, start, at</i></dt>
      <dd>
        An exact nonnegative integer less than the length of the bvector.
        In <i>bvector-copy!</i> and <i>reverse-bvector-copy!</i>,
        <i>at</i> refers to the destination and <i>start</i> to the source.
        <br />
        <br />
      </dd>

      <dt><i>end</i></dt>
      <dd>
        An exact nonnegative integer not less than <i>start</i>.
        This indicates the index directly before
        which traversal will stop &mdash; processing will occur until
        the index of the vector is one less than <code><i>end</i></code>.  It is the
        open right side of a range.
        <br />
        <br />
      </dd>

      <dt><i>f</i></dt>
      <dd>
        A procedure taking one or more
        arguments, which returns (except as noted otherwise) exactly one value.
        <br />
        <br />
      </dd>

      <dt><i>=</i></dt>
      <dd>
        An equivalence procedure.
        <br />
        <br />
      </dd>

      <dt><i>
        obj, seed, knil
      </i></dt>
      <dd>
        Any Scheme object.
        <br />
        <br />
      </dd>


      <dt><i>[something]</i></dt>
      <dd>
        An optional argument; it needn't necessarily be applied.
        <code><i>Something</i></code> needn't necessarily be one thing; for
        example, this usage of it is perfectly valid:
        <br />
        <br />
        <code>
          &nbsp;&nbsp;&nbsp;[start [end]]
        </code>
        <br />
        <br />
        and is indeed used quite often.
        <br />
        <br />
      </dd>

      <dt><i>something ...</i></dt>
      <dd>
        Zero or more <code><i>something</i></code>s are
        allowed to be arguments.
        <br />
        <br />
      </dd>

      <dt><i>
        something<sub>1</sub> something<sub>2</sub>
        ...
      </i></dt>
      <dd>
        At least one <code><i>something</i></code> must be
        arguments.
        <br />
        <br />
      </dd>

    </dl>

<p>All procedures that return bvectors, vectors, or lists newly allocate their results,
except for those in the "Mutators" and "Bitwise mutators" sections.</p>

<p>Except as otherwise noted, the semantics of each procedure are those
of the corresponding SRFI 133 or SRFI 151 procedure.<\/p>

<p>FIXME: Notations in curly braces are implementation comments which
will be removed before finalization.</p>

<H2>Procedures</H2>

<H3>Constructors</H3>

<p><code>(make-bvector <i>size</i> [<i>fill</i>]) -> bvector </code> {IW}</p>

<p>Returns a bvector whose length is <i>size</i>.  If <i>fill</i> is provided,
all the elements of the bvector are initialized to it.</p>

<p><code>(bvector <i>value ...</i>) -> bvector </code> {IW}</p>

<p>Returns a bvector initialized with <i>values</i>.</p>

<p><code>(bvector-unfold <i>f length seed</i>) -> bvector</code> {IW}</p>

<p>Creates a vector whose length is <i>length</i> and iterates across each index
<i>k</i> between 0 and <i>length</i>, applying <i>f</i> at each iteration to the current
index and current state, in that order, to receive two values: 
the element to put in the k<i>th</i> slot of the new vector and a new state
for the next iteration.
On the first call to <i>f</i>, the state's value is <i>seed</i>.</p>

<p><code>(bvector-unfold-right <i>f length seed</i>) -> bvector</code></p>

<p>The same as <code>bvector-unfold</code>, but initializes the bvector from right to left.</p>

<p><code>(bvector-copy <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> bvector</code></p>

<p>Makes a copy of the portion of <i>bvec</i> from <i>start</i> to <i>end</i> and returns it.</p>

<p><code>(bvector-reverse-copy <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> bvector</code></p>

<p>The same as <code>bvector-copy</code>, but in reverse order.</p>

<p><code>(bvector-append <i>bvec ...</i>) -> bvector</code></p>

<p>Returns a bvector containing all the elements of the <i>bvecs</i> in order.</p>

<p><code> (bvector-concatenate <i>list-of-bvectors</i>) -> bvector</code></p>

<p>The same as <code>bvector-append</code>, but takes a list of bvectors rather than
multiple arguments.</p>

<p><code>(bvector-append-subvectors [<i>bvec start end] ...</i>) -> bvector</code></p>

<p>Concatenates the result of applying <code>bvector-copy</code> to each triplet of
<i>bvec, start, end</i> arguments, but may be implemented more efficiently.</p>

<H3>Predicates</H3>

<p><code>(bvector? <i>obj</i>) -> boolean</code></p>

<p>Returns <code>#t</code> if <i>obj</i> is a bvector, and <code>#f</code>
otherwise.</p>

<p><code>(bvector-empty? <i>bvec</i>) -> boolean</code></p>

Returns <code>#t</code> if <i>bvec</i> has a length of zero,
and <code>#f</code> otherwise.</p>

<p><code>(bvector= <i>bvec ...</i>) -> boolean</code></p>

<p>Compares the <i>bvecs</i> for elementwise equality, using
<code>boolean=?</code> to do the comparisons.</p>

<H3>Selectors</H3>

<p><code>(bvector-ref <i>bvec i</i>) -> boolean</code></p>

<p>Returns the <i>i</i>th element of <i>bvec</i> as <code>#f</code> or <code>#t</code>.</p>

<p><code>(bvector-length <i>bvec</i>) -> exact nonnegative integer</code></p>

<p>Returns the length of <i>bvec</i></p>

<H3>Iteration</H3>

<p><code>(bvector-take <i>bvec n</i>) -> bvector</code></p>

<p><code>(bvector-take-right <i>bvec n</i>) -> bvector</code></p>

<p>Returns a bvector containing the first/last <i>n</i>
elements of <i>bvec</i>.</p>

<p><code>(bvector-drop <i>bvec n</i>) -> bvector</code></p>

<p><code>(bvector-drop-right <i>bvec n</i>) -> bvector</code></p>

<p>Returns a bvector containing all except the first/last <i>n</i>
elements of <i>bvec</i>.</p>

<p><code>(bvector-segment <i>bvec n</i>) -> list</code></p>

<p>Returns a list of bvectors, each of which contains <i>n</i>
consecutive elements of <i>bvec</i>.
The last bvector may be shorter than <i>n</i>.</p>

<p><code>(bvector-fold <i>kons knil bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> object</code></p>

<p><code>(bvector-fold-right <i>kons knil bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> object</code></p>

<p>Folds <i>kons</i> over the elements of <i>bvec</i>
in increasing/decreasing order using <i>knil</i>
as the initial value.</p>

<p><code>(bvector-map <i>f bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> unspecified</code></p>

<p><code>(bvector-map! <i>f bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> unspecified</code></p>

<p><code>(bvector-map->list <i>f bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> list</code></p>

<p><code>(bvector-for-each <i>f bvec<sub>1</sub> bvec<sub>2</sub> ...</i>) -> unspecified</code></p>

<p>Iterate over the corresponding elements of the <i>bvecs</i> and apply <i>f</i>
to each, returning respectively a bvector of the results,
an undefined value with the results placed back in <i>bvec1</i>,
a list of the results,
and an undefined value with no change to <i>bvec</i>.</p>


<H3>Prefixes, suffixes, trimming, padding</H3>

<p><code>(bvector-prefix-length <i>bool bvec1 bvec2</i> -> index</code></p>

<p><code>(bvector-suffix-length <i>bool bvec1 bvec2</i> -> index</code></p>

<p>Return the number of elements equal to <i>bool</i> in the prefix/suffix 
of the two <i>bvecs</i>.</p>

<p><code>(bvector-prefix? <i>bvec1 bvec2</i> -> boolean</code></p>

<p><code>(bvector-suffix? <i>bvec1 bvec2</i> -> boolean</code></p>

Returns <code>#t</code> if <i>bvec1</i> is a prefix/suffix of <i>bvec2</i>,
and <code>#f</code> otherwise.</p>

<p><code>(bvector-pad <i> bool bvec length</i>) -> bvec</code></p>
<p><code>(bvector-pad-right <i> bool bvec length</i>) -> bvec</code></p>

<p>Returns a copy of <i>bvec</i> with leading/trailing
elements equal to <i>bool</i>
added (if necessary) so that the length of the result
is <i>length</i>.</p>

<p><code>(bvector-trim <i>bvec</i>) -> bvec</code></p>
<p><code>(bvector-trim-right <i>bvec</i>) -> bvec</code></p>
<p><code>(bvector-trim-both <i>bvec</i>) -> bvec</code></p>

<p>Returns a copy of <i>bvec</i> with leading/trailing/both
elements equal to <i>bool</i> removed.</p>

<H3>Mutators</H3>

<p><code>(bvector-set! <i>bvec i value</i>) -> unspecified</code></p>

<p>Sets the <i>i</i>th element of <i>bvec</i> to <i>value</i>.</p>

<p><code>(bvector-swap! <i>bvec i j</i>) -> unspecified</code></p>

<p>Interchanges the <i>i</i>th and <i>j</i>th elements of <i>bvec</i>.</p>

<p><code>(bvector-fill! <i>bvec fill</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Fills the portion of <i>bvec</i> from <i>start</i> to <i>end</i>
with the value <i>fill</i>.</p>

<p><code>(bvector-reverse! <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Reverses the portion of <i>bvec</i> from <i>start</i> to <i>end</i>.</p>

<p><code>(bvector-copy! <i>to at from</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>Copies the portion of <i>from</i> from <i>start</i> to <i>end</i>
onto <i>to</i>, starting at index <i>at</i>.

<p><code>(bvector-reverse-copy! <i>to at from</i> [<i>start</i> [<i>end</i>]]) -> unspecified</code></p>

<p>The same as <code>bvector-copy!</code>, but copies in reverse.</p>

<H3>Conversion</H3>

<p><code>(bvector->list <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code></p>

<p><code>(reverse-bvector->list <i>bvec</i> [<i>start</i> [<i>end</i>]]) -> proper-list</code></p>

<p><code>(list->bvector <i>proper-list</i>) -> bvector</code></p>

<p><code>(reverse-list->bvector <i>proper-list</i>) -> bvector</code></p>

<p><code>(bvector->vector <i>bvec</i>) -> vector</code></p>

<p><code>(vector->bvector <i>vec</i>) -> bvector</code></p>


<p>Returns a list, bvector, or heterogeneous vector with the same
elements as the argument, in reverse order where specified.</p>

<p><code>(bvector->string <i>bvec</i>) -> string</code></p>

Returns a string beginning with <code>#*</code> and followed by the values of <i>vec</i>
represented as 0 and 1 characters, where 0 means <code>#f</code>
and 1 means <code>#t</code>.

<p><code>(string->bvector <i>string</i>) -> bvector</code></p>

Parses a string in the format generated by <code>bvector->string</code>
and returns the corresponding bvector, or <code>#f</code> if the
string is not in this format.</p>

<p>
<code>(bvector->integer </code><em>bvector</em> [ <em>len</em> ]<code>)</code><br />
</p>
<p>
Returns a non-negative integer whose bits, starting with the least significant bit as bit 0,
correspond to the values in <em>bvector</em>.
</p>
<p>
<code>(integer->bvector </code><em>integer</em><code>)</code><br />
</p>
<p>
Returns a bvector whose values correspond to the bits of <em>integer</em>,
starting with the least significant bit as bit 0.  It is an error if
<em>integer</em> is negative.
</p>

<h3>Generators</h3>
<p>
<code>(make-bvector-generator </code><em>bvector</em><code>)</code>
</p>
<p>
Returns a <a href="http://srfi.schemers.org/srfi-121/srfi-121.html">SRFI 121</a>
generator that generates all the values of <em>bvector</em> in order.
Note that the generator is finite.
</p>
<H2>Bitwise operations</H2>

<p>
In this section, "bit" is a synonym for "boolean", used for parallelism
with SRFI 151.
</p>

<p>Procedures whose names end in <code>!</code> are the same as the
corresponding procedures without <code>!</code>, except that the first
bvector argument is mutated and an unspecified result is returned.</p>
<p>
It is an error unless all <em>bvector</em>
arguments passed to the following procedures are of the same length.
</p>

<h3 id="Basicoperations">Basic operations</h3>
<p> <code>(bvector-not </code><em>bvec</em><code>)</code> </p>
<p> <code>(bvector-not! </code><em>bvec</em><code>)</code> </p>
<p>
Returns the element-wise complement of <em>bvec</em>; that is, all <code>#t</code> values are changed
to <code>#f</code> values and all <code>#f</code> values to <code>#t</code> values.
</p>
<p>
The following ten procedures correspond to the useful set
of non-trivial two-argument boolean functions. For each such function,
the corresponding bvector operator
maps that function across two or more bvectors in a element-wise fashion.
The core idea of this group of functions is this element-wise "lifting"
of the set of dyadic boolean functions to bvector parameters.  </p>
<p> <code>(bvector-and </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<p> <code>(bvector-and! </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-ior </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-ior! </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-xor </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-xor! </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-eqv </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code><br />
<code>(bvector-eqv! </code><em>bvec1</em> <em>bvec2</em> <em>bvec</em> ...<code>)</code>
</p>
<p>
These operations are associative.
</p>
<p>
The <code>bvector-eqv</code> procedure produces the
complement of the <code>bvector-xor</code> procedure.  When applied to three
arguments, it does <em>not</em> produce a <code>#t</code> value
everywhere that a, b and c all agree. That is, it does <em>not</em> produce
</p>
<pre>
     (bvector-ior (bvector-and a b c)
                  (bvector-and (bvector-not a)
                               (bvector-not b)
                               (bvector-not c)))
</pre>
<p>
Rather, it produces <code>(bvector-eqv a (bvector-eqv b c))</code> or the equivalent
<code>(bvector-eqv (bvector-eqv a b) c)</code>.
</p>
<p>
<code>(bvector-nand </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-nand </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-nor </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-nor </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-andc1 </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-andc1 </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-andc2 </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-andc2 </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-orc1 </code><em>bvec1 bvec2</em><code>)</code><br />
<code>(bvector-orc2 </code><em>bvec1 bvec2</em><code>)</code>
<code>(bvector-orc2 </code><em>bvec1 bvec2</em><code>)</code>
</p>
<p>
<p>
These operations are not associative.
</p>
<h3 id="Quasiintegeroperations">Quasi-integer operations</h3>
<p>
<code>(bvector-logical-shift </code><em>bvec count</em><code>)</code>
</p>
<p>
Returns a bvector equal in length to <em>bvec</em>
containng the logical left shift when <em>count</em>>=0
or the right shift when <em>count</em>&lt;0.
Newly vacated elements are filled with <code>#f</code>s.
</p>
<p>
<code>(bvector-count </code><em>bvec1 bvec2 ...</em><code>)</code>
</p>
<p>
Returns the population count of <code>#t</code>'s in <em>bvec</em>.
</p>
<p>
<p>
<code>(bvector-if </code><em>if-bvector then-bvector else-bvector</em><code>)</code>
</p>
<p>
Returns a bvector that
merges the bvectors <em>then-bvector</em> and <em>else-bvector</em>,
with the bvector <em>if-bvector</em> determining
from which bvector to take each value.
That is, if the <em>k</em>th value of <em>if-bvector</em> is <code>#t</code>,
then the <em>k</em>th bit of the result is the <em>k</em>th bit of <em>then-bvector</em>,
otherwise the <em>k</em>th bit of <em>else-bvector</em>.  
</p>


<p>
<code>(bvector-first-set-bit </code><em>bvec</em><code>)</code>
</p>
<p>
Return the index of the first (smallest index) <code>#t</code> value in <em>bvec</em>.
Return -1 if <em>bvec</em> contains no <code>#t</code> values.
</p>
<h3 id="Bitfieldoperations">Bit field operations</h3>
<p>
These procedures operate on a contiguous field of bits (a "byte," in
Common Lisp parlance) in a given bvector. The <em>start</em> and <em>end</em>
arguments, which are not optional, are
non-negative exact integers specifying the field: it is the <em>end-start</em> bits
running from bit <em>start</em> to bit <em>end</em>-1.
</p>
<p>
<code>(bvector-field </code><em>bvec start end</em><code>)</code>
</p>
<p>
Returns a bvector containing
the field from <em>bvec</em>, shifted
down to the least-significant position in the result.
</p>



<p>
<code>(bvector-field-any? </code><em>bvec start end</em><code>)</code>
</p>
<p>
Returns true if any of the field's bits are set in <em>bvec</em>, and false otherwise.
</p>



<p>
<code>(bvector-field-every? </code><em>bvec start end</em><code>)</code>
</p>
<p>
  Returns false if any of the field's bits are not set in <em>bvec</em>, and true otherwise.
</p>


<p>
<code>(bvector-field-clear </code><em>bvec start end</em><code>)</code><br />
<code>(bvector-field-set </code><em>bvec start end</em><code>)</code>
</p>
<p>
Returns a bvector containing
<em>bvec</em> with the field's bits set to all
<code>#f</code>s/<code>#t</code>s.
</p>


<p>
<code>(bvector-field-replace </code><em>dest source start end</em><code>)</code>
</p>
<p>
Returns a bvector containing
<em>dest</em> with the field replaced
by the least-significant <em>end-start</em> bits in <em>source</em>.
</p>



<p>
<code>(bvector-field-replace-same </code><em>dest source start end</em><code>)</code>
</p>
<p>
Returns a bvector containing
<em>dest</em> with its field replaced
by the corresponding field in <em>source</em>.
</p>


<p>
<code>(bvector-field-rotate </code><em>bvec count start end</em><code>)</code>
</p>
<p>
Returns <em>bvec</em> with the field cyclically permuted
by <em>count</em> bits towards high-order.
</p>



<p>
<code>(bvector-field-reverse </code><em>bvec start end</em><code>)</code>
</p>
<p>
Returns <em>bvec</em> with the order of the bits in the field reversed.
</p>

<p>
<code>(bvector-field-flip </code><em>bvec start end</em><code>)</code>
</p>
<p>
Returns <em>bvec</em> with the bits in the field flipped:
that is, <code>#t</code> becomes <code>#f</code> and vice versa.  There is no SRFI 151 equivalent.
</p>




<h3>Bitwise mutators</h3>
<p>The operations
<code>bvector-not!</code>,
<code>bvector-and!</code>,
<code>bvector-ior!</code>,
<code>bvector-xor!</code>,
<code>bvector-eqv!</code>,
<code>bvector-nand!</code>,
<code>bvector-nor!</code>,
<code>bvector-andc1!</code>,
<code>bvector-andc2!</code>,
<code>bvector-orc1!</code>,
<code>bvector-orc2!</code>,
<code>bvector-field-clear!</code>,
<code>bvector-field-set!</code>,
<code>bvector-field-replace!</code>,
<code>bvector-field-replace-same!</code>,
<code>bvector-field-rotate!</code>,
<code>bvector-field-reverse!</code>,
and
<code>bvector-field-flip!</code>
have the same semantics as their counterparts without
<code>!</code>, except that instead of allocating a
result bvector, the first bvector argument is mutated
and an unspecified value returned.</p>

<H1>Implementation</H1>

<p>The sample implementation is (not yet) in the repository of this SRFI.
Bvectors are wrapped bytevectors; for simplicity and possibly for speed,
they use a whole byte to represent each boolean, as Java and C# do.
At a later date, a more
complex implementation that packs booleans into bytes
but still operates bytewise as much as possible <i>might</i> be provided.


<H1>Copyright</H1>
Copyright &copy; John Cowan 2018.
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>


<hr>
<address>Editor: <a href="mailto:srfi minus editors at srfi dot schemers dot org">
  Arthur A. Gleckler</a></address>

  </body>
</html>
