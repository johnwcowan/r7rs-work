The following table compares the names of the bitwise (aka logical) functions of [[http://www.lispworks.com/documentation/HyperSpec/Body/c_number.htm|Common Lisp]], [[http://srfi.schemers.org/srfi-33/srfi-33.html|SRFI 33]], [[http://srfi.schemers.org/srfi-60/srfi-60.html|SRFI 60]], [[http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-12.html#node_sec_11.4|R6RS]], and BitwiseCowan.  SRFI 33 was never finalized, but is a comprehensive proposal.  SRFI 60 (based on SLIB) is smaller but has a few procedures of its own; some of its procedures have both native (often CL) and SRFI 33 names.  R6RS is a subset of SRFI 60, but all procedure names begin with a `bitwise-` prefix.

||=Function=||=CL=||=SRFI 33=||=SRFI 60=||=R6RS=||=Cowan=||
||Bitwise NOT||`lognot`||`bitwise-not`||`lognot`, `bitwise-not`||`bitwise-not`||`bitwise-not`||
||Bitwise AND (variadic)||`logand`||`bitwise-and`||`logand`, `bitwise-and`||`bitwise-and`||`bitwise-and`||
||Bitwise IOR (variadic)||`logior`||`bitwise-ior`||`logior`, `bitwise-ior`||`bitwise-ior`||`bitwise-ior`||
||Bitwise XOR (variadic)||`logxor`||`bitwise-xor`||`logxor`, `bitwise-xor`||`bitwise-xor`||`bitwise-xor`||
||Bitwise EQV (variadic)||`logeqv`||`bitwise-eqv`||---||---||`bitwise-xor`||
||Bitwise NAND (variadic)||`lognand`||`bitwise-nand`||---||---||`bitwise-nand`||
||Bitwise NOR (variadic)||`lognor`||`bitwise-nor`||---||---||`bitwise-nor`||
||Bitwise EQV (variadic)||`logeqv`||`bitwise-eqv`||---||---||`bitwise-xor`||
||Bitwise AND with NOT of first arg||`logandc1`||`bitwise-andc1`||---||---||`bitwise-andc1`||
||Bitwise AND with NOT of second arg||`logandc2`||`bitwise-andc2`||---||---||`bitwise-andc2`||
||Bitwise OR with NOT of first arg||`logorc1`||`bitwise-orc1`||---||---||`bitwise-orc1`||
||Bitwise OR with NOT of second arg||`logorc2`||`bitwise-orc2`||---||---||`bitwise-orc2`||
||Arithmetic shift||`ash`||`arithmetic-shift`||`ash`, `arithmetic-shift`||`bitwise-arithmetic-shift`||`arithmetic-shift`||
||Population count||`logcount`||`bit-count`||`logcount`, `bit-count`||`bitwise-bit-count`||`bit-count`||
||Integer length||`integer-length`||`integer-length`||`integer-length`||`bitwise-integer-length`||`integer-length`||
||Integer length||`integer-length`||`integer-length`||`integer-length`||`bitwise-integer-length`||`integer-length`||
||Mask selects source of bits||---||`bitwise-merge`||`bitwise-if`, `bitwise-merge`||`bitwise-if`||`bitwise-if`||
||Test single bit||`logbitp`||`bit-set?`||`logbit?`, `bit-set?`||`bitwise-bit-set?`||`bit-set?`||
||See if any mask bits set||`logtest`||`any-bits-set?†`||`logtest`, `any-bit-set?`||---||
||See if all mask bits set||---||`all-bits-set?`†||---||---||`every-bit-set?`||
||Replace single bit||---||---||`copy-bit`||`bitwise-copy-bit`||`copy-bit`||
||Find first bit set||---||`first-set-bit`||`log2-binary-factors`, `first-set-bit`||---||`first-set-bit`||
||Extract bit field*||`ldb`||`extract-bit-field`||`bit-field`||`bitwise-bit-field`||`bit-field`||
||Test bit field*||`ldb-test`||`test-bit-field?`†||---||---||---||
||Clear bit field||`mask-field`||`clear-bit-field`||---||---||---||
||Replace bit field*||`dpb`||`replace-bit-field`||`copy-bit-field`||`bitwise-copy-bit-field`||`replace-bit-field`||
||Replace corresponding bit field||`deposit-field`||`copy-bit-field`||---||---||`replace-same-bit-field`||
||Rotate bit field||---||---||`rotate-bit-field`||`bitwise-rotate-bit-field`||`rotate-bit-field`||
||Reverse bit field||---||---||`reverse-bit-field`||`bitwise-reverse-bit-field`||`reverse-bit-field`||
||Integer to boolean list||---||---||`integer->list`||---||`integer->list`||
||Boolean list to integer||---||---||`list->integer`||---||`list->integer`||
||Booleans to integer||---||---||`booleans->integer`||---||`bits`||

*These procedures take a byte-spec object in Common Lisp (which encodes size and position), leading ''size'' and ''position'' arguments in SRFI-33, and trailing ''start'' and ''end'' arguments in SRFI-60, R6RS (where present), and BitwiseCowan.  Consequently, they are not quite compatible across specifications.  Note that `copy-bit-field` corresponds to different procedures in SRFI 33 and SRFI 60.

†In [[http://srfi.schemers.org/srfi-33/mail-archive/msg00023.html|late changes to SRFI 33]] that were never consummated, Olin Shivers changed `any-bits-set?` to `any-bit-set?`, `all-bits-set?` to `every-bit-set?`, and split `test-bit-field?` into `bit-field-any?` and `bit-field-every?`.  BitwiseCowan adopts these changes.

BitwiseCowan adopts the SRFI 33 names for its procedures with a few exceptions.  The name `bitwise-if` used in SRFI 60 and R6RS replaces `bitwise-merge`.  Because of the conflict around `copy-bit-field` noted above, I have introduced the names `replace-bit-field` and `replace-same-bit-field`, which are more explicit.

The procedures that do not exist in SRFI 33 have their SRFI 60 names, with one exception.  The SRFI 60 procedure `booleans->integer` is a convenient way to specify a bitwise integer in the absence of datum syntax (it accepts an arbitrary number of boolean arguments and returns an integer), so I gave it the short name `bits`, roughly analogous to `list`, `string`, and `vector`.