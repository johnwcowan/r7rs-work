== Flonums package ==

''Flonums'' are a subset of the inexact real numbers provided by a Scheme implementation.  In most Schemes, the flonums and the inexact reals are the same.

== R6RS flonum library ==

The R6RS-specific integer division procedures have been removed, as have the condition types.

{{{
#!html
<p>
This section uses <i>fl</i>, <i>fl<sub>1</sub></i>, <i>fl<sub>2</sub></i>, etc., as
parameter names for flonum arguments, and <i>ifl</i>
as a name for integer-valued flonum arguments, i.e., flonums for which the
<tt>integer?</tt> predicate returns true.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_950"></a>flonum?<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a flonum, <tt>#f</tt> otherwise.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_952"></a>real-&gt;flonum<i> x</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the best flonum representation of
<i>x</i>.</p>
<p>
The value returned is a flonum that is numerically closest to the
argument.</p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
If flonums are represented in binary floating point, then
implementations should break ties by preferring
the floating-point representation whose least significant bit is
zero.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_954"></a>fl=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_956"></a>fl&lt;?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_958"></a>fl&lt;=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_960"></a>fl&gt;?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_962"></a>fl&gt;=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return <tt>#t</tt> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
<tt>#f</tt> otherwise.  These
predicates must be transitive.</p>
<p>
</p>

<tt>(fl=&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt>
<p class=nopadding>(fl=&nbsp;-inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl=&nbsp;-inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(fl=&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(fl&lt;&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl=&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl&lt;&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_964"></a>flinteger?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_966"></a>flzero?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_968"></a>flpositive?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_970"></a>flnegative?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_972"></a>flodd?<i> ifl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_974"></a>fleven?<i> ifl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_976"></a>flfinite?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_978"></a>flinfinite?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_980"></a>flnan?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These numerical predicates test a flonum for a particular property,
returning <tt>#t</tt> or <tt>#f</tt>.
The <tt>flinteger?</tt> procedure tests whether the number object is an integer,
<tt>flzero?</tt> tests whether
it is <tt>fl=?</tt> to zero, <tt>flpositive?</tt> tests whether it is greater
than zero, <tt>flnegative?</tt> tests whether it is less
than zero, <tt>flodd?</tt> tests whether it is odd, 
<tt>fleven?</tt> tests whether it is even,
<tt>flfinite?</tt> tests whether it is not an infinity and not a NaN,
<tt>flinfinite?</tt> tests whether it is an infinity, and
<tt>flnan?</tt> tests whether it is a NaN.</p>
<p>
</p>

<tt>(flnegative?&nbsp;-0.0)&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt>
<p class=nopadding>(flfinite?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(flfinite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(flinfinite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(flinfinite?&nbsp;+inf.0)&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#t</tt></p>
<p></tt></p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
<tt>(flnegative? -0.0)</tt> must return <tt>#f</tt>,
else it would lose the correspondence with
<tt>(fl&lt; -0.0 0.0)</tt>, which is <tt>#f</tt>
according to IEEE 754&nbsp;[[<a|href="r6rs-lib-Z-H-21.html#node_bib_7">7</a>]].
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_982"></a>flmax<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_984"></a>flmin<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the maximum or minimum of their arguments.
They always return a NaN when one or more of the arguments is a NaN.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_986"></a>fl+<i> <i>fl<sub>1</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_988"></a>fl*<i> <i>fl<sub>1</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations
that represent flonums using IEEE binary floating point, the
meaning of &ldquo;best&rdquo; is defined by the IEEE standards.)</p>
<p>
</p>

<tt>(fl+&nbsp;+inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0
<p class=nopadding>(fl+&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>

<p class=nopadding>(fl*&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_990"></a>fl-<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_992"></a>fl-<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_994"></a>fl/<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_996"></a>fl/<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.  With one argument, however, they return the additive or
multiplicative flonum inverse of their argument.  In general, they
should return the flonum that best approximates the mathematical
difference or quotient.  (For implementations that represent flonums
using IEEE binary floating point, the meaning of &ldquo;best&rdquo; is
reasonably well-defined by the IEEE standards.)</p>
<p>
</p>

<tt>(fl-&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
For undefined quotients, <tt>fl/</tt> behaves as specified by the
IEEE standards:</p>
<p>
</p>

<tt>(fl/&nbsp;1.0&nbsp;0.0)&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0
<p class=nopadding>(fl/&nbsp;-1.0&nbsp;0.0)&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-inf.0</p>

<p class=nopadding>(fl/&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_998"></a>flabs<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the absolute value of <i>fl</i>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1012"></a>flnumerator<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1014"></a>fldenominator<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the numerator or denominator of <i>fl</i>
as a flonum; the result is computed as if <i>fl</i> was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.
</p>

<tt>(flnumerator&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flnumerator&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-inf.0</p>

<p class=nopadding>(fldenominator&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;1.0</p>

<p class=nopadding>(fldenominator&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;1.0</p>

<p class=nopadding>(flnumerator&nbsp;0.75)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;3.0&nbsp;;&nbsp;probably</p>

<p class=nopadding>(fldenominator&nbsp;0.75)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;4.0&nbsp;;&nbsp;probably</p>
<p></tt></p>
<p>
Implementations should implement following behavior:</p>
<p>
</p>

<tt>(flnumerator&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-0.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1016"></a>flfloor<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1018"></a>flceiling<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1020"></a>fltruncate<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1022"></a>flround<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.  For such arguments, <tt>flfloor</tt> returns the
largest integral flonum not larger than <i>fl</i>.  The <tt>flceiling</tt>
procedure
returns the smallest integral flonum not smaller than <i>fl</i>.
The <tt>fltruncate</tt> procedure returns the integral flonum closest to <i>fl</i> whose
absolute value is not larger than the absolute value of <i>fl</i>.
The <tt>flround</tt> procedure returns the closest integral flonum to <i>fl</i>,
rounding to even when <i>fl</i> represents a number halfway between two integers.</p>
<p>
Although infinities and NaNs are not integer objects, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN:</p>
<p>
</p>

<tt>(flfloor&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flceiling&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-inf.0</p>

<p class=nopadding>(fltruncate&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1024"></a>flexp<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1026"></a>fllog<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1028"></a>fllog<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1030"></a>flsin<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1032"></a>flcos<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1034"></a>fltan<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1036"></a>flasin<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1038"></a>flacos<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1040"></a>flatan<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1042"></a>flatan<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures compute the usual transcendental functions.  
The <tt>flexp</tt> procedure computes the base-<em>e</em> exponential of <i>fl</i>.
The <tt>fllog</tt> procedure with a single argument computes the natural logarithm of
<i>fl</i> (not the base ten logarithm); <tt>(fllog <i>fl<sub>1</sub></i>
<i>fl<sub>2</sub></i>)</tt> computes the base-<i>fl<sub>2</sub></i> logarithm of <i>fl<sub>1</sub></i>.
The <tt>flasin</tt>, <tt>flacos</tt>, and <tt>flatan</tt> procedures compute arcsine,
arccosine, and arctangent, respectively.  <tt>(flatan <i>fl<sub>1</sub></i>
<i>fl<sub>2</sub></i>)</tt> computes the arc tangent of <i>fl<sub>1</sub></i>/<i>fl<sub>2</sub></i>.</p>
<p>
See report
section&nbsp;on &ldquo;Transcendental functions&rdquo; for the underlying
mathematical operations.  In the event that these operations do not
yield a real result for the given arguments, the result may be a NaN,
or may be some unspecified flonum.</p>
<p>
Implementations that use IEEE binary floating-point arithmetic 
should follow the relevant standards for these procedures.</p>
<p>
</p>

<tt>(flexp&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0
<p class=nopadding>(flexp&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;0.0</p>

<p class=nopadding>(fllog&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0</p>

<p class=nopadding>(fllog&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-inf.0</p>

<p class=nopadding>(fllog&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>unspecified</i><br>
;&nbsp;if&nbsp;-0.0&nbsp;is&nbsp;distinguished</p>

<p class=nopadding>(fllog&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+nan.0</p>

<p class=nopadding>(flatan&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-1.5707963267948965<br>
;&nbsp;approximately</p>

<p class=nopadding>(flatan&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;1.5707963267948965<br>
;&nbsp;approximately</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1044"></a>flsqrt<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the principal square root of <i>fl</i>. For &minus;0.0,
<tt>flsqrt</tt> should return &minus;0.0; for other negative arguments,
the result may be a NaN or some unspecified flonum.</p>
<p>
</p>

<tt>(flsqrt&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flsqrt&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-0.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1046"></a>flexpt<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Either <i>fl<sub>1</sub></i> should be non-negative, or, if <i>fl<sub>1</sub></i> is
negative, <i>fl<sub>2</sub></i> should be an integer object.
The <tt>flexpt</tt> procedure returns <i>fl<sub>1</sub></i> raised to the power <i>fl<sub>2</sub></i>.  If <i>fl<sub>1</sub></i> is
negative and <i>fl<sub>2</sub></i> is not an integer object, the result may be a
NaN, or may be some unspecified flonum.  If <i>fl<sub>1</sub></i> is zero, then
the result is zero.
</p>
<p></p>
<p>
</p>

<p></p>
<div align=left><tt>(<a name="node_idx_1060"></a>fixnum-&gt;flonum<i> fx</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns a flonum that is numerically closest to <i>fx</i>.</p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
The result of this procedure may not be
numerically equal to <i>fx</i>, because the fixnum precision
may be greater than the flonum precision.
</blockquote>
<p></p>
<p>
</p>
}}}

== Integer division ==

{{{
#!html
<p>
<tt>(floor/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(floor-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(floor-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
</p>
<p>
<tt>(ceiling/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(ceiling-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(ceiling-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
</p>
<p>
<tt>(truncate/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(truncate-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(truncate-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
</p>
<p>
<tt>(round/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(round-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(round-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<p>
<tt>(euclidean/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(euclidean-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(euclidean-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
</p>
<p>
<tt>(balanced/ </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(balanced-quotient </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
<tt>(balanced-remainder </tt><em>dividend</em><tt> </tt><em>divisor</em><tt>)</tt><br />
</p>
}}}

These are variants of the DivisionRiastradh integer division functions that accept flonums and return a flonum.

`(decode-float `''z''`)` and friends

See [[http://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm|CL DECODE-FLOAT and friends]].


== C99 <math.h> constants ==

The following constants are defined in terms of the constants of the <math.h> header of ISO/IEC 9899:1999 (C language).

||Scheme name||C name||Comments||
||`fl:e`||`M_E`||Value of e||
||`fl:log2-e`||`M_LOG2E`||Value of log,,2,, e||
||`fl:log10-e`||`M_LOG10E`||Value of log,,10,, e||
||`fl:ln-2`||`M_LN2`||Value of log,,e,, 2||
||`fl:ln-10`||`M_LN10`||Value of log,,e,, 10||
||`fl:pi`||`M_PI`||Value of pi||
||`fl:pi/2`||`M_PI_2`||Value of pi/2||
||`fl:pi/4`||`M_PI_4`||Value of pi/4||
||`fl:one-over-pi`||`M_1_PI`||Value of 1/pi||
||`fl:two-over-pi`||`M_2_PI`||Value of 2/pi||
||`fl:two-over-sqrt-pi`||`M_2_SQRTPI`||Value of 2/sqrt(pi)||
||`fl:sqrt-2`||`M_SQRT2`||Value of sqrt(2)||
||`fl:one-over-sqrt-2`||`M_SQRT1_2`||Value of 1/sqrt(2)||
||`fl:maximum-flonum`||`HUGE_VAL`||`+inf.0` or else\\the largest finite flonum||
||`fl:fast-multiply-add`||`#t` if `FP_FAST_FMA` is 1,\\or `#f` otherwise||multiply-add is fast||
||`fl:integer-exponent-zero`||`FP_ILOGB0`||what `(flinteger-binary-log 0)` returns||
||`fl:integer-exponent-nan`||`FP_ILOGBNAN`||what `(flinteger-binary-log +0.nan)` returns||

== C99 <math.h> procedures ==

The following procedures are defined in terms of the functions of the <math.h> header of ISO/IEC 9899:1999 (C language).  In the C signatures, the types "double" and "int" are mapped to Scheme flonums and (suitably bounded) Scheme exact integers respectively.

||Scheme name||C signature||Comments||
||`flacosh`||`double      acosh(double)`||hyperbolic arc cosine||
||`flasinh`||`double      asinh(double)`||hyperbolic arc sine||
||`flatanh`||`double      atanh(double)`||hyperbolic arc tangent||
||`flcbrt`||`double      cbrt(double);`||cube root||
||`flcomplementary-error-function`||`double      erfc(double)`||-||
||`flcopy-sign`||`double      copysign(double x, double y)`||result has magnitude of x and sign of y||
||`flcosh`||`double      cosh(double)`||hyperbolic cosine||
||`flmake-flonum`||`double      ldexp(double x, int n)`||x*2^n^||
||`flerror-function`||`double      erf(double)`||-||
||`flexp`||`double exp(double)`||e^x^||
||`flexp-binary`||`double      exp,,2,,(double)`||base-2 exponential||
||`flexp-minus-1`||`double      expm1(double)`||e^x^-1||
||`flexponent`||`double      logb(double x)`||the exponent of x, which is the integral part of log_r(|x|), as a signed floating-point value, for non-zero x, where r is the radix of the machine's floating-point arithmetic||
||`flfirst-bessel-order-0`||`double      j0(double)`||bessel function of the first kind, order 0||
||`flfirst-bessel-order-1`||`double      j1(double)`||bessel function of the first kind, order 1||
||`flfirst-bessel`||`double      jn(int n, double)`||bessel function of the first kind, order n||
||`flfraction-exponent`||`double      modf(double, double *)`||returns two values, fraction and int exponent||
||`flgamma`||`double      tgamma(double)`||-||
||`flhypotenuse`||`double      hypot(double, double)`||sqrt(x^2^+y^2^)||
||`flinteger-exponent`||`int         ilogb(double)`||binary log as int||
||`fllog-binary`||`double      log2(double)`||log base 2||
||`fllog-decimal`||`double      log10(double)`||log base 10||
||`fllog-gamma`||`double      lgamma(double)`||returns two values, log(|gamma(x)|) and sgn(gamma(x))||
||`fllog-one-plus`||`double      log1p(double x)`||log (1+x)||
||`flmultiply-add`||`double      fma(double a, double b, double c)`||a*b+c||
||`flnext-after`||`double      nextafter(double, double)`||next flonum following x in the direction of y||
||`flnormalized-fraction-exponent`||`double      frexp(double, int *)`||returns two values, fraction in range [1/2,1) and int exponent||
||`flpositive-difference`||`double      fdim(double, double)`||-||
||`flremquo`||`double      remquo(double, double, int *)`||returns two values, rounded remainder and low-order ''n'' bits of the quotient (''n'' is implementation-defined)
||`flscalbn`||`double      scalbn(double x, int y)`||x*r^y^, where r is the machine float radix||
||`flsecond-bessel-order-0`||`double      y0(double)`||bessel function of the second kind, order 0||
||`flsecond-bessel-order-1`||`double      y1(double)`||bessel function of the second kind, order 1||
||`flsecond-bessel`||`double      yn(int n, double)`||bessel function of the second kind, order ''n''||
||`flsinh`||`double      sinh(double)`||hyperbolic sine||
||`fltanh`||`double      tanh(double)`||hyperbolic tangent||


== General remarks ==

In the event that these operations do not yield a real result for the given arguments, the result may be `+nan.0`, or may be some unspecified flonum.

Implementations that use IEEE binary floating-point arithmetic should follow the relevant standards for these procedures.

== C99 <complex.h> constants ==

The following constants are defined in terms of the constants of the <math.h> header of ISO/IEC 9899:1999 (C language).

||Scheme name||C name||Comments||
||cx:i||I||0+1i as a compnum||


== Compnum procedures from <complex.h> ==

A ''compnum'' is a general complex number whose `real-part` and `imag-part` are both flonums.  The following procedures should be in a different library from the flonum procedures.

||Scheme name||C signature||Comments||
||`cxabs`||`double cabs(double complex)`||same as magnitude||
||`cxacos`||`double complex cacos(double complex)`||-||
||`cxacosh`||`double complex cacosh(double complex)`||-||
||`cxangle`||`double carg(double complex)`||-||
||`cxasin`||`double complex casin(double complex)`||-||
||`cxasinh`||`double complex casinh(double complex)`||-||
||`cxatan`||`double complex catan(double complex)`||-||
||`cxatanh`||`double complex catanh(double complex)`||-||
||`cxconjugate`||`double complex conj(double complex)`||complex conjugate||
||`cxcos`||`double complex ccos(double complex)`||-||
||`cxcosh`||`double complex ccosh(double complex)`||-||
||`cxexp`||`double complex cexp(double complex)`||-||
||`cxexpt`||`double complex cpow(double complex, double complex)`||-||
||`cximag-part`||`double cimag(double complex)`||-||
||`cxlog`||`double complex clog(double complex)`||-||
||`cxmagnitude`||`double cabs(double complex)`||same as abs||
||`cxprojection`||`double complex  cproj(double complex)`||projects to Riemann sphere
||`cxreal-part`||`double creal(double complex)`||-||
||`cxsin`||`double complex csin(double complex)`||-||
||`cxsinh`||`double complex csinh(double complex)`||-||
||`cxsqrt`||`double complex csqrt(double complex)`||-||
||`cxtan`||`double complex ctan(double complex)`||-||
||`cxtanh`||`double complex ctanh(double complex)`||-||

The following are general complex number functions, not just for compnums.

`(cis `''z''`)`

Returns e^i''z''^, a complex number whose real part is cos ''z'' and whose imaginary part is sin ''z''.

`(signum `''z''`)`

Returns a complex number whose phase is the same as ''z'' but whose magnitude is 1, unless ''z'' is zero, in which case it returns ''z''.  As a consequence of this definition, negative real numbers return -1, positive real numbers return 1, and zero returns zero.

 