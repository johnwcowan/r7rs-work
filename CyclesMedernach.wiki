== Cycle type ==

Cycles are an immutable ordered, but unindexed, container type similar to circular lists.

The idea is to make a cycle type disjoint from the other types, only interface is standardized. Scheme implementations are free to use any underlying structure to achieve it.

=== Constructor and type conversion === 

`(make-cycle `''list''`)`

Constructs and returns a new cycle whose elements are the elements of ''list''.

`(cycle `''element'' ...`)`

Constructs and returns a new cycle containing ''elements''.

`(cycle->list `''cycle''`)`

Constructs and returns a list whose elements are those of ''cycle''.

=== Predicates ===

`(cycle? `''obj''`)`

Returns `#t` if obj is a cycle, and otherwise returns `#f`.

`(cycle=? `''equivalence cycle,,1,, cycle,,2,,''`)`

Return `#t` if ''cycle,,1,,'' and ''cycle,,2,,'' contain the same values (in the sense of the ''equivalence'' predicate) in the same order, independent of their rotations; otherwise return `#f`.

Example:  `(cycle=? (make-cycle 1 2 3) (make-cycle 3 1 2)) => t`

=== Accessors ===

`(cycle-length `''cycle''`)`

Returns the number of elements in ''cycle''.

`(cycle-front `''cycle''`)`

Returns the element in front of ''cycle''.

`(cycle-rotate `''cycle''` `''k''`)`

''cycle-rotate'' returns a cycle obtained from ''cycle'' by a rotation of ''k'' steps, which is an exact integer.  If ''k'' is positive, the rotation is forward; if ''k'' is negative, the rotation is backward; if ''k'' is zero, there is no rotation.

`(cycle-find `''cycle pred'' [[|''reversed?'' ]]`)`

''cycle-find'' returns a cycle obtained from ''cycle'' by a rotation of as few steps as possible such that the value of `cycle-front` satisfies `pred`.  If ''reversed?'' is true (by default it is false), the rotation goes in the reverse direction.

=== Functional update ===

`(cycle-remove-front `''cycle''`)`

''cycle-remove-front'' returns a cycle obtained from ''cycle'' where the front element has been removed.

`(cycle-insert `''cycle''` `''obj''`)`

Return a cycle where ''obj'' is put in front in ''cycle''.

=== Mapping and folding ===

`(cycle-map `''proc''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles'' and returning a single value. `cycle-map` applies ''proc'' to the elements of the cycle(s) and returns a newly allocated cycle of the corresponding results.

`(cycle-for-each `''proc''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles''. `cycle-for-each` applies ''proc'' to the elements of the cycle(s) and discards any results.

`(cycle-fold `''proc''` `''nil''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles'', plus one additional argument, and returning a single value. `cycle-fold` applies ''proc'' to the elements of the cycle(s) and the value previously returned by ''proc''.  On the first call to ''proc'', the additional argument is ''nil''.  Returns the result of the final call to ''proc''.

`(cycle-unfold `''continue? successor mapper seed''`)`

Start with an empty list.  If the result of applying the predicate ''continue?'' to ''seed'' is `#f`, apply `make-cycle` to the reversed list and return the result.  Otherwise, apply the procedure ''mapper'' to ''seed''.  The value of ''mapper'' is prepended onto the list.  Then get a new seed by applying the procedure ''successor'' to ''seed'', and repeat this algorithm.

=== External representations ===

The cycle composed of elements 1, 2 and 3 with 1 in front can be written as following:

  `#cycle(1 2 3)`

== Ideas from SRFI 1 ==

take, drop, take-reversed, drop-reversed, reverse, count, filter, partition, remove, any, every
