## Introduction

## Specialized and generalized arrays

The SRFI provides two varieties of arrays, specialized and generalized,
but attempts to hide the differences between them as much as possible.
A specialized array corresponds to arrays in other programming languages:
it is mutable and maintains a *storage object* which holds the values of the array.
A storage object is one-dimensional, and maps an exact integer from 0 (inclusive)
to the number of elements in its array (exclusive) to the value.  The mapping
between the multiple indices of the array and the single index of the storage
object is managed by the implementation.

Specialized arrays guarantee that
retrieving the value of a given array element
specified by its indices always retrieves
the same value unless a mutation is performed, in which case
retrievals provide the value of the latest mutation.

More than one specialized array may in certain circumstances
share the same storage object.  In this case, a mutation performed on an
element of one array is typically (but not invariably) visible in all other
arrays that share its storage object.

Generalized arrays do not have storage objects maintained by the implementation.
Instead they are constructed using a getter procedure
that retrieves the value of a specified array element.
This procedure may or may not return the same value over time in the way
that specialized arrays do.

For example, a getter that fetches the value of a particular row
and column of a relational database table will produce different results if the
table is mutated through some other process.  This sort of immutable array
is not truly immutable, but simply cannot be mutated through the SRFI.
Another example is an array whose elements are generated by an algorithm.
If this algorithm is pure and functional, the array is truly immutable.

It is also possible to create a generalized array with both a getter and a
setter procedure, in which case it is considered mutable.
Because of the ability to do arbitrary mutations, it
must be backed by mutable storage of some sort,
though it need not be as stereotyped as a storage object.
By convention, such an array should normally provide
the same guarantees as a specialized array.  

## Intervals, storage classes, and array constructors

In order to construct an array,
the lower and upper bounds of all its dimensions must be known.
In the SRFI, these are represented using an immutable object
called a (multi-dimensional) *interval*,
which can be constructed using the following procedure:

`(make-interval `*lower-bounds upper-bounds*`)`

Returns a multidimensional interval
whose lower bounds are specified by the vector *lower-bounds*
and whose corresponding upper bounds are specified by the vector *upper-bounds*.
For example, the interval for a two-dimensional array whose first dimension
(rows) ranges from 0 to 9 and whose second dimension ranges from -5 to +5, inclusive,
is created with `(make-interval #(0 -5) #(10 6))`.

Note that an interval can be used to construct more than one array.

In order to construct a specialized array, however,
it is also necessary to specify the *storage class*,
which represents the type of the storage object for an array.
The following standard storage classes are provided:

`generic-storage-class`

A storage class that allows any value to be stored, as a Scheme vector does.
However, a storage object belonging to
this class is not necessarily a Scheme vector.

`@-storage-class`

Storage classes that allow particular sets of numbers to be stored
The character `@` is shorthand for one of `u8`, `s8`, ... `c128`,
the twelve homogeneous-vector datatypes
of [SRFI 160](http://srfi.schemers.org/srfi-160/srfi-160.html).
However, a storage object belonging to
one of these classes is not necessarily a SRFI 160 @vector.

The procedure `make-storage-class` can be used to create
a specialized kind of backing store.  For example, a hash table
along with a default value such as 0
can provide a compact backing store for sparse arrays.

With intervals and storage classes available, we can construct arrays:

`(make-specialized-array `*interval* [ *storage-class* [ *safe?* ] ]`)`

Returns a specialized array whose dimensions are specified by *interval*
using as its backing store an object of the class specified by *storage-class*
(`generic-storage-class` by default).

If the *safe?* argument is true, operations on the returned array will be checked
for being within *interval* in the sense of `interval-contains-multi-index`.
If it is false, operations are not checked.  If *safe* is omitted, the value
is implementation-dependent.

`(make-array `*intervall getter* [ *setter* ]`)`

Returns a generalized array whose dimensions are specified by *interval*.
The *getter* procedure accepts array indices as multiple arguments
and returns the value of an array element specified by those indices

The *setter* procedure accepts a new value
followed by array indices as multiple arguments
and changes the array element specified by those indices to the new value,
returning an unspecified value.
If *setter* is not provided, the generalized array is immutable.

## Predicates

The following predicates are useful for type dispatch:

`(interval? `*object*`)`

Return `#t` if *object* is an interval
and `#f` otherwise.

`(array? `*object*`)`

Return `#t` if *object* is an array
and `#f` otherwise.

`(specialized-array? `*object*`)`

Returns `#t` if *object* is a specialized array
and `#f` otherwise.

`(mutable-array? `*object*`)`

Returns `#t` if *object* is a mutable array, either
generalized or specialized,
and `#f` otherwise.

The following special-purpose predicate
allows a program to check in advance
whether a particular sequence of indices is
usable with a particular array:

`(interval-contains-multi-index? `*interval index0 index1* ...`)`

Returns `#t` if the element specified by the *indexes*
is included in *interval*, and `#f` otherwise.
The interval associated with
an array can be obtained using the `array-domain` accessor.

## Individual array elements

There are no generic `array-ref` or `array-set!` procedures provided.
Instead, individual array elements can be retrieved or changed
using the `array-getter` and `array-setter` procedures, as follows:

`((array-getter `*array*`)` *index0 index1* ...`)`

Returns the value of *array* specified by the *indexes*.

`((array-setter `*array*`)` *newvalue index1 index2* ...`)`

Changes the value of array specified by the *indexes* to *newvalue*.

Note that specialized arrays have getters and setters just like generalized
arrays, although they are provided by the implementation rather than the user.

## Affine transformations

`(array-extract `*array interval*`)`

`(array-tile `*array intvector*`)`

`(array-translate `*array translation*`)`

The `translation?` predicate can be used to
verify that *translation* represents
a meaningful translation of array indices
(that is, if every element is an exact integer).

`(array-permute `*array permutation*`)`

The `permutation?` predicate can be used to
verify that *translation* represents
a meaningful translation of array indices
(that is, if each element is a distinct exact integer
in the range 0 (inclusive)
to the length of *permutation* (exclusive)).

`(array-curry `*array dimension*`)`

`(array-reverse `*array flip?*`)`

`(array-sample `*array scales*`)`

## The whole array

The following procedures accept a predicate and some arrays
and apply the predicate to each corresponding element of the arrays:

`(array-any `*pred array1 array2* ...`)`

Invokes *pred* on the corresponding elements of the *arrays* in lexicographic order.
As soon as a call to *pred* returns true, its value is returned by `array-any`.
If all calls return false, `array-any` returns false.

`(array-every `*pred array1 array2* ...`)`

Invokes *pred* on the corresponding elements of the *arrays* in lexicographic order.
As soon as a call to *pred* returns false, `array-any` returns false.
If all calls return true, the value of the last call is returned by `array-any`.

## Mapping and folding

`(array-map `*proc array1 array2* ...`)`

`(array-for-each `*proc array1 array2* ...`)`

`(array-fold `*kons knil array*`)`  
`(array-fold-right `*kons knil array*`)`

`(array-outer-product `*proc array1 array2*`)`


## Mutators

These procedures allow bulk mutation of arrays.  The
arrays must have equivalent intervals.

`(array-assign! `*dst src*`)`

Copies the elements of the array *src* into the corresponding locations
of the array *dst*, which must be mutable.
It is an error if the arrays do not have the same interval.

`(array-swap! `*array1 array2*`)`

Swaps the corresponding elements of *array1* and *array2*,
which must both be mutable.
It is an error if the arrays do not have the same interval.

## Conversions

`(list->specialized-array `*interval storage-class safe?*`)`

Copies the elements of *list* into the positions
of a newly created specialized array in lexicographic order.
The arguments *interval*, *storage-class*, and *safe?* have the same meaning
as in `make-specialized-array`.  Returns the newly created array.

`(array->specialized-array `*array storage-class safe?*`)`

Copies the elements of *array* into the corresponding positions
of a newly created specialized array of the same dimensions
in lexicographic order.
The arguments *storage-class* and *safe?* have the same meaning
as in `make-specialized-array`.  Returns the newly created array.

`(array-list `*array*`)`

Returns a list containing the elements of *array* in lexicographic order.

`