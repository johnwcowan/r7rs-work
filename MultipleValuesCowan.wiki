== Multiple values procedures ==

`(values . `''values''`)`

Returns multiple values.

`(call-with-values `''producer'' ...` `''consumer''`)`

Invoke the ''producers'' and pass all values returned by them in order to ''consumer''.  This extends R5RS by allowing more than one ''producer''.  Equivalent to Common Lisp's `multiple-value-call`.  See #87.

== Multiple values macros ==

`(let-values ((`''lambda-list''` `''expression''`)` ...`) `''body''`)` 

Each ''lambda-list'' should be a formal arguments list as for a `lambda` expression, cf. section 4.1.4 of the R5RS.

The ''expressions'' are evaluated in the current environment, the variables of the ''lambda-list'' are bound to fresh locations, the return values of the ''expressions'' are stored in the variables, the ''body'' is evaluated in the extended environment, and the values of the last expression of ''body'' are returned. The ''body'' is a tail body, cf. section 3.5 of the R5RS.

The matching of each ''lambda-list'' to values is done in the same way as in a `lambda` expression, and it is an error for an ''expression'' to return a number of values that does not match its corresponding ''lambda-list''.  (From SRFI 11.)

{{{
             (let-values (((a b . c) (values 1 2 3 4)))
               (list a b c))            --> (1 2 (3 4))

             (let ((a 'a) (b 'b) (x 'x) (y 'y))
               (let-values (((a b) (values x y))
                            ((x y) (values a b)))
                 (list a b x y)))       --> (x y a b)
}}}

`(let*-values ((`''lambda-list''` `''expression''`)` ...`) `''body''`)` 

`let*-values` is similar to `let-values`, but the bindings are performed sequentially from left to right, and the region of a binding indicated by (<formals> <expression>) is the part of the `let*-values` expression to the right of the binding. Thus the second binding is done in an environment in which the first binding is visible, and so on.  (From SRFI 11.)

{{{
             (let ((a 'a) (b 'b) (x 'x) (y 'y))
               (let*-values (((a b) (values x y))
                             ((x y) (values a b)))
                 (list a b x y)))       --> (x y x y)
}}}


`(set!-values (`''lambda-list''`) `''expression''`)`

Assigns the values returned by ''expression'' to the variables in ''lambda-list''.
Returns undefined values.  Equivalent to Common Lisp's `multiple-variable-setq`.

`(define-values (`''var'' ...`) `''expr''`)`

Defines the ''vars'' and binds them to the values of ''expr''.

